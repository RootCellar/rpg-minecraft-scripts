# General

on script load:
	broadcast "&c[&eRPG Skript&c] &3Loading script..."

on script unload:
	broadcast "&c[&eRPG Skript&c] &3Unloading script..."

	loop {rpgSkript::fireballs::*}:
		delete {rpgSkript::fireballs::%loop-index%::caster}
		delete {rpgSkript::fireballs::%loop-index%::loc}
		delete {rpgSkript::fireballs::%loop-index%::time}
		delete {rpgSkript::fireballs::%loop-index%::v}
		delete {rpgSkript::fireballs::%loop-index%}

	loop {rpgSkript::cryoballs::*}:
		delete {rpgSkript::cryoballs::%loop-index%::caster}
		delete {rpgSkript::cryoballs::%loop-index%::loc}
		delete {rpgSkript::cryoballs::%loop-index%::time}
		delete {rpgSkript::cryoballs::%loop-index%::v}
		delete {rpgSkript::cryoballs::%loop-index%}

on join:
	wait 3 seconds
	send "&c-------- &eMinecraft RPG &c--------" to player
	send "&l&eNew&r&e:" to player

	# Example: send "&3 - <stuff>" to player
	
	send "&3 - Tools and armor will now last longer for Warriors and Rogues" to player
	send "&3 - Rogues now get hungry substantially slower" to player
	send "&3 - Rogues now resist 70 percent of fall damage" to player
	send "&3 - Wizards can now conjure iron golems for 1,500 Mana" to player
	send "&3 - Warriors can now make power attacks with pickaxes, breaking all blocks in a small radius" to player
	send "&3 - Warrior's power attacks now have a cooldown" to player
	send "&3 - Warriors now resist knockback" to player
	send "&3 - Rogues get additional items at random when killing monsters and animals" to player
	
	#send "&3" to player

	send "&c-------- &eMinecraft RPG &c--------" to player
	

on chat:
	set the message to "&6[&8LVL %player's level%&6]&r %message%"
	hasClass(player, "rogue") is true:
		set the message to "&7[&2Rogue&7]&r %message%"
	hasClass(player, "warrior") is true:
		set the message to "&e[&cWarrior&e]&r %message%"
	hasClass(player, "wizard") is true:
		set the message to "&8[&3Wizard&8]&r %message%"
	hasClass(player, "paladin") is true:
		set the message to "&6[&9Paladin&6]&r %message%"
	hasClass(player, "cleric") is true:
		set the message to "&3[&eCleric&3]&r %message%"
	hasClass(player, "herobrine") is true:
		set the message to "&0[&4Herobrine&0]&r %message%"

function rpgLog(message: text):
	log "%{_message}%" to "rpg/main.log"

function hasClass(player: player, class: text) :: boolean:
	if {_player} has permission "rpg.%{_class}%":
		return true
	if hasImbue({_player}, "%{_class}% class") is true:
		return true
	if hasLore({_player}'s held item, "%{_class}% class") is true:
		return true
	return false

function isMonster(entity: entity) :: boolean:
	{_entity} is a player:
		hasClass({_entity}, "herobrine") is true:
			return true
	{_entity} is a monster:
		return true
	return false

function setMaxHealth(player: player):
	set {_newMax} to 10
	if hasClass({_player}, "herobrine") is true:
		set {_newMax} to 40
	else if hasClass({_player}, "warrior") is true:
		set {_newMax} to 20
		if hasResearch({_player}, "durable") is true:
			set {_newMax} to {_newMax} * 1.25
	else if hasClass({_player}, "wizard") is true:
		set {_newMax} to 8
	else:
		set {_newMax} to 10

	if hasImbue({_player}, "Health Boost") is true:
		set {_newMax} to ({_newMax} + {_newMax} * 0.15 * countImbue({_player}, "Health Boost"))

	if {_player}'s maximum health is not {_newMax}:
		set {_player}'s maximum health to {_newMax}
		send "&cYour maximum health has changed to %{_newMax}% hearts" to {_player}

function lastLoreLine(item: item) :: number:
	set {_x} to 1
	loop lore of {_item}:
		set {_x} to {_x} + 1
	return {_x}

function countImbue(player: player, text: text) :: number:
	set {_c} to 0
	if hasLore({_player}'s helmet, {_text}) is true:
		set {_c} to {_c} + 1
	if hasLore({_player}'s chestplate, {_text}) is true:
		set {_c} to {_c} + 1
	if hasLore({_player}'s leggings, {_text}) is true:
		set {_c} to {_c} + 1
	if hasLore({_player}'s boots, {_text}) is true:
		set {_c} to {_c} + 1
	return {_c}

function hasImbue(player: player, text: text) :: boolean:
	if hasLore({_player}'s helmet, {_text}) is true:
		return true
	if hasLore({_player}'s chestplate, {_text}) is true:
		return true
	if hasLore({_player}'s leggings, {_text}) is true:
		return true
	if hasLore({_player}'s boots, {_text}) is true:
		return true
	return false

function hasLore(item: item, text: text) :: boolean:
	loop lore of {_item}:
		if loop-value contains {_text}:
			return true
	return false

function isWearingLightOrLess(player: player) :: boolean:
	hasLore(helmet of {_player}, "light") is false:
		helmet of {_player} is not (leather helmet or air):
			return false
	hasLore(chestplate of {_player}, "light") is false:
		chestplate of {_player} is not (leather chestplate or air):
			return false
	hasLore(leggings of {_player}, "light") is false:
		leggings of {_player} is not (leather leggings or air):
			return false
	hasLore(boots of {_player}, "light") is false:
		boots of {_player} is not (leather boots or air):
			return false
	hasLore(off hand item of {_player}, "light") is false:
		off hand item of {_player} is shield:
			return false
	return true

function isWearingMediumOrLess(player: player) :: boolean:
	if isWearingLightOrLess({_player}) is true:
		return true
	hasLore(helmet of {_player}, "light") is false:
		helmet of {_player} is (diamond helmet or netherite helmet):
			return false
	hasLore(chestplate of {_player}, "light") is false:
		chestplate of {_player} is (diamond chestplate or netherite chestplate):
			return false
	hasLore(leggings of {_player}, "light") is false:
		leggings of {_player} is (diamond leggings or netherite leggings):
			return false
	hasLore(boots of {_player}, "light") is false:
		boots of {_player} is (diamond boots or netherite boots):
			return false
	return true

function isWearingHeavyOrLess(player: player) :: boolean:
	return true

function addResearch(player: player, name: string, level: number=1):
	set {rpgSkript::%{_player}%::research::%{_name}%} to {_level}
	send "&eYou have earned research ""%{_name}%"" Level %{_level}%" to {_player}

function deleteResearch(player: player, name: string):
	delete {rpgSkript::%{_player}%::research::%{_name}%}
	send "&cYou have lost research ""%{_name}%""" to {_player}

function hasResearch(player: player, name: string) :: boolean:
	if {rpgSkript::%{_player}%::research::%{_name}%} is set:
		return true
	return false

function getResearchLevel(player: player, name: string) :: number:
	if {rpgSkript::%{_player}%::research::%{_name}%} is not set:
		return 0
	return {rpgSkript::%{_player}%::research::%{_name}%}

function explodeRadius(block: block, range: number):
	loop all blocks in radius {_range} around {_block}:
		loop-block is not bedrock:
			break loop-block naturally using diamond pickaxe

local function drawLine(loc1: location, loc2: location):
	set {_v} to vector from {_loc1} to {_loc2}
	set vector length of {_v} to 0.25
	loop floor((distance between {_loc1} and {_loc2}) / 0.25) times:
		draw 1 flame at {_loc1} with extra 0
		set {_loc1} to {_loc1} ~ {_v}

function playSoundToPlayers(loc: location, sound: string, range: number, pitch: number=1):
	loop players in radius {_range} of {_loc}:
		play sound "%{_sound}%" with pitch {_pitch} for loop-player

command /haslore <text>:
	executable by: players
	trigger:
		send "hasImbue: %hasImbue(command executor, arg 1)%"

command /armorclass:
	executable by: players
	trigger:
		send "Light or less: %isWearingLightOrLess(command executor)%"
		send "Medium or less: %isWearingMediumOrLess(command executor)%"
		send "Heavy or less: %isWearingHeavyOrLess(command executor)%"

function arcaneTide():
	{rpgSkript::arcaneTide} is not set:
		set {_x} to a random number between 1 and 1000
		#broadcast {_x}
		{_x} < 7:
			set {rpgSkript::arcaneTide} to now
			arcaneSense("You feel the surrounding energy of Magic become more intense!")
	else:
		if difference between now and {rpgSkript::arcaneTide} is greater than 2 minutes:
			set {_x} to a random number between 1 and 1000
			#broadcast {_x}
			{_x} < 20:
				delete {rpgSkript::arcaneTide}
				arcaneSense("The energy in the air settles...")

function countEntities(mobs: entities) :: number:
	set {_x} to 0
	loop {_mobs::*}:
		set {_x} to {_x} + 1
	return {_x}

on heal:
	entity is not alive:
		cancel the event

function heal(entity: entity, amount: number) :: boolean:
	if {_entity} is not alive:
		return false
	heal {_entity} by {_amount}
	return true

on join:
	setMaxHealth(the player)
	set the player's health to the player's health

every 3 seconds:
	loop all players:
		clear loop-player's scoreboard
		set title of loop-player's scoreboard to "&eInformation"
		set line 15 of loop-player's scoreboard to "&a"
		set line 14 of loop-player's scoreboard to "&3&l   RPG"
		set line 13 of loop-player's scoreboard to "&a"
		set line 12 of loop-player's scoreboard to "&3 Mana: %{rpgSkript::%loop-player%::mana}% / %{rpgSkript::%loop-player%::maxMana}%"

		hasClass(loop-player, "rogue") is true:
			set line 9 of loop-player's scoreboard to "Monsters: %countEntities(monsters within 20 meters of loop-player)%"
			set line 8 of loop-player's scoreboard to "Animals: %countEntities(animals within 30 meters of loop-player)%"
			set line 7 of loop-player's scoreboard to "Players: %countEntities(players within 50 meters of loop-player)%"
			set line 6 of loop-player's scoreboard to "Items on Ground: %countEntities(dropped items within 30 meters of loop-player)%"

every 2 seconds:

	arcaneTide()

	loop all players:
		setMaxHealth(loop-player)

		setupMana(loop-player)
		regenMana(loop-player)
		
		hasClass(loop-player, "wizard") is true:
			if hasResearch(loop-player, "power") is true:
				add 3 experience to loop-player
		hasClass(loop-player, "warrior") is true:
			heal(loop-player, 1)
			loop-player's knockback resistance attribute is not 0.7:
				set loop-player's knockback resistance attribute to 0.7
			apply haste 2 without particles to the loop-player for 30 seconds replacing the existing effect
			apply strength 2 without particles to the loop-player for 30 seconds replacing the existing effect
		hasClass(loop-player, "paladin") is true:
			heal(loop-player, 2)
		hasClass(loop-player, "herobrine") is true:
			#enable flight for loop-player
			heal(loop-player, 2)
			loop-player's knockback resistance attribute is not 0.9:
				set loop-player's knockback resistance attribute to 0.9
			apply haste 6 without particles to the loop-player for 30 seconds replacing the existing effect
			apply strength 4 without particles to the loop-player for 30 seconds replacing the existing effect

on damage:
	attacker is a player:
		hasClass(attacker, "rogue") is true:
			canUseRogueAbilities(attacker) is true
			set the damage to the damage * 2.0
		hasClass(attacker, "herobrine") is true:
			set the damage to the damage * 3.0
			
	victim is a player:
		setMaxHealth(the victim)

		hasClass(victim, "herobrine") is true:
			set the damage to the damage * 0.3
			damage cause is fall:
				cancel the event
			damage cause is burn:
				cancel the event
			damage cause is lava:
				cancel the event
			damage cause is hot floor:
				cancel the event
			damage cause is drowning:
				cancel the event
			damage cause is freeze:
				cancel the event
		hasClass(victim, "warrior") is true:
			set {_odamage} to the damage
			set {_newdamage} to {_odamage} * 0.65
			set the damage to {_newdamage}
		hasClass(victim, "rogue") is true:
			canUseRogueAbilities(victim) is true
			damage cause is fall:
				set the damage to the damage * 0.3
			chance of 45%:
				set the damage to 0
				play sound "entity.player.attack.nodamage" at victim
				send action bar "&2~ ~ DODGE ~ ~" to victim

on target:
	target is a player
	hasClass(target, "herobrine") is true:
		cancel the event
		stop
	hasClass(target, "rogue") is true:
		canUseRogueAbilities(target) is true
		distance between event-entity and target is greater than 10:
			cancel the event
			stop
		chance of 80%:
			cancel the event
			stop

on item damage:
	hasClass(player, "herobrine") is true:
		cancel the event
	hasClass(player, "paladin") is true:
		subMana(player, 2) is true:
			cancel the event
	hasClass(player, "warrior") is true:
		chance of 45%:
			cancel the event
			#send "&cSaved durability"
	hasClass(player, "rogue") is true:
		chance of 25%:
			cancel the event
			#send "&2Saved durability"

# Warrior

command /warriorresearch:
	executable by: players
	trigger:
		hasClass(player, "warrior") is false:
			send "&dYou are not a warrior!"
			exit
		set {_menu} to a new chest inventory with 6 rows named "&cWarrior Research"
		
		populateWarriorResearchMenu(player, {_menu})
		
		open {_menu} to player

function populateWarriorResearchMenu(player: player, menu: inventory):
	set {_item} to red wool named "&7Master Smith"
	if hasResearch({_player}, "master_smith") is true:
		set {_item} to lime wool named "&eMaster Smith"
	set line 1 of {_item}'s lore to "&6Tools and Armor that you craft are enchanted"
	set slot 30 of {_menu} to {_item}

	set {_item} to red wool named "&7Durable"
	if hasResearch({_player}, "durable") is true:
		set {_item} to lime wool named "&eDurable"
	set line 1 of {_item}'s lore to "&6Maximum Health is increased by 25%%"
	set slot 31 of {_menu} to {_item}

	set {_item} to red wool named "&7Tree Feller"
	if hasResearch({_player}, "tree_feller") is true:
		set {_item} to lime wool named "&eTree Feller"
	set line 1 of {_item}'s lore to "&6You cut trees down instantly"
	set slot 32 of {_menu} to {_item}

on inventory click:
	name of event-inventory is "&cWarrior Research"
	cancel event

	if index of event-slot is 30:
		if hasResearch(player, "master_smith") is true:
			deleteResearch(player, "master_smith")
		else:
			addResearch(player, "master_smith")
	if index of event-slot is 31:
		if hasResearch(player, "durable") is true:
			deleteResearch(player, "durable")
		else:
			addResearch(player, "durable")
	if index of event-slot is 32:
		if hasResearch(player, "tree_feller") is true:
			deleteResearch(player, "tree_feller")
		else:
			addResearch(player, "tree_feller")

	populateWarriorResearchMenu(player, event-inventory)

on mine of any log:
	hasClass(player, "warrior") is true
	player's tool is an axe
	if hasResearch(player, "tree_feller") is true:
		cancel the event
		fellTree(event-block)

function fellTree(block: block, depth: number=1):
	if {_depth} is greater than 300:
		exit
	if {_block} is not any log or any leaves:
		exit

	set {_recurse} to false
	{_block} is any log:
		set {_recurse} to true
		
	break {_block} naturally using a diamond axe
		
	if {_recurse} is true:
		loop blocks in radius 2 of {_block}:
			fellTree(loop-block, {_depth} + 1)

on craft:
	hasClass(player, "warrior") is true
	if hasResearch(player, "master_smith") is true:
		wait 1 tick
		event-item is any sword:
			enchant the cursor slot of player with sharpness 1
		event-item is any pickaxe:
			enchant the cursor slot of player with efficiency 1
		event-item is any axe:
			enchant the cursor slot of player with efficiency 1
		event-item is any shovel:
			enchant the cursor slot of player with unbreaking 1
		event-item is any hoe:
			enchant the cursor slot of player with unbreaking 1
		event-item is any armor:
			enchant the cursor slot of player with protection 1
	

on right click:
	hasClass(player, "warrior") is true

	set {_didHit} to false
	set {_can_power_attack} to false
	
	if {rpgSkript::%player%::powerattack_time} is not set:
		set {_can_power_attack} to true
	if difference between now and {rpgSkript::%player%::powerattack_time} is more than 4 seconds:
		set {_can_power_attack} to true

	if {_can_power_attack} is true:
		player is holding a sword:
			loop all monsters in radius 5 around player:
				set {_didHit} to true
				apply slowness 3 to loop-monster for 7 seconds replacing the existing effect
				damage loop-entity by 3
				set {_vec} to normalized vector between player and loop-entity
				push loop-entity {_vec} with force 0.9
				push loop-entity upwards with force 0.6
				
		player is holding an axe:
			set {_loc} to the location 2 meters below and 3 meters horizontally behind the player
			set {_vec} to normalized vector between {_loc} and player
			loop all monsters in radius 5 around player:
				set {_didHit} to true
				apply slowness 3 to loop-monster for 7 seconds replacing the existing effect
				damage loop-entity by 2
				push loop-entity {_vec} with force 1.2
		
		player is holding a pickaxe:
			distance between player and player's targeted block is less than 5:
				create an explosion with force 0 at player's targeted block
				loop all blocks in radius 2 around player's targeted block:
					loop-block is not bedrock:
						set {_didHit} to true
						break loop-block naturally using player's held item

		if {_didHit} is true:
			set {rpgSkript::%player%::powerattack_time} to now
			apply slowness 3 to player for 4 seconds replacing the existing effect
			send action bar "&c&lPOWER ATTACK" to the player
				
	else:
		send action bar "&cYour power attack is still on cooldown!" to the player

# Rogue

function canUseRogueAbilities(player: player) :: boolean:
	if {_player} has potion effect slowness:
		return false
	if hasResearch({_player}, "fit") is true:
		if isWearingMediumOrLess({_player}) is true:
			return true
		return false
	else:
		if isWearingLightOrLess({_player}) is true:
			return true
		return false

command /rogueresearch:
	executable by: players
	trigger:
		hasClass(player, "rogue") is false:
			send "&dYou are not a rogue!"
			exit
		set {_menu} to a new chest inventory with 6 rows named "&aRogue Research"
		
		populateRogueResearchMenu(player, {_menu})
		
		open {_menu} to player

function populateRogueResearchMenu(player: player, menu: inventory):
	set {_item} to red wool named "&7Fit"
	if hasResearch({_player}, "fit") is true:
		set {_item} to lime wool named "&eFit"
	set line 1 of {_item}'s lore to "&6You may now wear Medium armor"
	set slot 31 of {_menu} to {_item}

on inventory click:
	name of event-inventory is "&aRogue Research"
	cancel event
	
	if index of event-slot is 31:
		if hasResearch(player, "fit") is true:
			deleteResearch(player, "fit")
		else:
			addResearch(player, "fit")

	populateRogueResearchMenu(player, event-inventory)

on death of a monster:
	attacker is a player
	hasClass(attacker, "rogue") is true
	set {_x} to a random number between 0 and 1000
	if {_x} <= 350:
		add 3 arrows to the drops
	if {_x} <= 80:
		add 1 raw gold to the drops
	if {_x} <= 45:
		add 1 diamond to the drops

on death of an animal:
	attacker is a player
	hasClass(attacker, "rogue") is true
	set {_x} to a random number between 0 and 1000
	if {_x} < 80:
		add 2 leather to the drops

on death of a player:
	hasClass(victim, "rogue") is true:
		keep the items
		clear drops
		send "&aYou may have died, but they'll never get your items!" to the victim

on sprint toggle:
	hasClass(player, "rogue") is true
	player is not sprinting:
		canUseRogueAbilities(player) is true
		apply swiftness 2 without particles to the player for 30 seconds replacing the existing effect
		apply jump boost 2 without particles to the player for 30 seconds replacing the existing effect
	player is sprinting:
		remove swiftness from the player
		remove jump boost from the player

on sneak toggle:
	hasClass(player, "rogue") is true
	player is not sneaking:
		canUseRogueAbilities(player) is true
		light level at the player is less than 11
		apply invisibility without particles to the player for 600 seconds replacing the existing effect
		loop all monsters in radius 40 of player:
			target of loop-monster is player:
				reset target of loop-monster
	player is sneaking:
		remove invisibility from the player

on jump:
	entity is a player
	hasClass(player, "rogue") is true:
		player is sprinting
		if canUseRogueAbilities(player) is true:
			push the player horizontally forward with force 0.7

on hunger meter change:
	hasClass(player, "rogue") is true
	if {rpgSkript::%player%::eating} is true:
		set {rpgSkript::%player%::eating} to false
		stop
	else:
		chance of 80%:
			cancel the event

on consume:
	set {rpgSkript::%player%::eating} to true

# Herobrine?

on death of a player:
	hasClass(victim, "herobrine") is true:
		keep the items and experience
		clear drops
		send "&7Using your dark powers, you vanish!" to the victim
		play sound "entity.ender_dragon.death" with pitch 0.5 at victim

every 1 seconds:
	loop all players:
		hasClass(loop-player, "herobrine") is true
		sunlight level at the loop-player is greater than 10
		time in world of loop-player is not between 19:00 and 5:00
		ignite the loop-player for 5 seconds
		send action bar "&4The daylight burns!" to loop-player
		damage loop-player by 12

on hunger meter change:
	hasClass(player, "herobrine") is true
	if {rpgSkript::%player%::filling_hunger} is true:
		delete {rpgSkript::%player%::filling_hunger}
		stop trigger
	else if the player's hunger meter is less than 10:
		set {rpgSkript::%player%::filling_hunger} to true
		set the player's hunger meter to 10

on sprint toggle:
	hasClass(player, "herobrine") is true
	player is not sprinting:
		apply swiftness 4 without particles to the player for 600 seconds replacing the existing effect
		apply jump boost 4 without particles to the player for 600 seconds replacing the existing effect
	player is sprinting:
		remove swiftness from the player
		remove jump boost from the player

on sneak toggle:
	hasClass(player, "herobrine") is true
	player is not sneaking:
		apply invisibility without particles to the player for 600 seconds replacing the existing effect
	player is sneaking:
		remove invisibility from the player

on jump:
	entity is a player
	hasClass(player, "herobrine") is true:
		player is sprinting
		push the player horizontally forward with force 1.5

# Wizard

on place of lightning rod:
	add event-block to {rpgSkript::lightning_rod::*}
	rpgLog("%player% placed lightning rod in %world% at %location of block%")
	send "&dThis lightning rod will catch lightning from magic as well!" to event-player

on break of lightning rod:
	remove event-block from {rpgSkript::lightning_rod::*}
	rpgLog("%player% broke lightning rod in %world% at %location of block%")

function isLightningRodWithinRangeOf(loc: location, range: number, strike: boolean=false) :: boolean:
	loop blocks in {rpgSkript::lightning_rod::*}:
		if loop-block is not lightning rod:
			remove loop-block from {rpgSkript::lightning_rod::*}
			rpgLog("lightning rod was listed at %{_loc}%, but block was not actually a lightning rod")
		else if loop-block is within {_range} meters of {_loc}:
			if {_strike} is true:
				create lightning effect at loop-block
			return true
		return false

function setupMana(player: player):
	if {rpgSkript::%{_player}%::mana} is not set:
		set {rpgSkript::%{_player}%::mana} to 0
	if {rpgSkript::%{_player}%::maxMana} is not set:
		set {rpgSkript::%{_player}%::maxMana} to 0

	set {_newMax} to 0
	if hasClass({_player}, "herobrine") is true:
		set {_newMax} to (level of {_player}) * 45
	else if hasClass({_player}, "wizard") is true:
		if isWearingLightOrLess({_player}) is true:
			set {_newMax} to (level of {_player}) * 9
		else if isWearingMediumOrLess({_player}) is true:
			set {_newMax} to (level of {_player}) * 7
		else:
			set {_newMax} to (level of {_player}) * 1.5
	else if hasClass({_player}, "cleric") is true:
		set {_newMax} to 1000
	else if hasClass({_player}, "paladin") is true:
		set {_newMax} to 30

	if hasImbue({_player}, "Mana Boost") is true:
		set {_newMax} to {_newMax} + 0.25 * {_newMax} * countImbue({_player}, "Mana Boost")
		
	if {_newMax} is not {rpgSkript::%{_player}%::maxMana}:
		set {rpgSkript::%{_player}%::maxMana} to {_newMax}
		send "&dYour maximum mana has changed to %{_newMax}%" to {_player}

function checkMana(player: player):
	setupMana({_player})
	if {rpgSkript::%{_player}%::mana} > {rpgSkript::%{_player}%::maxMana}:
		set {rpgSkript::%{_player}%::mana} to {rpgSkript::%{_player}%::maxMana}
	if {rpgSkript::%{_player}%::mana} < 0:
		set {rpgSkript::%{_player}%::mana} to 0

function regenMana(player: player):
	if {rpgSkript::%{_player}%::mana} is not set:
		setupMana({_player})
	if {rpgSkript::%{_player}%::maxMana} is not set:
		setupMana({_player})

	set {_add} to 0
	if hasClass({_player}, "herobrine") is true:
		set {_add} to {rpgSkript::%{_player}%::maxMana} / 100
	else if hasClass({_player}, "wizard") is true:
		if isWearingLightOrLess({_player}) is true:
			set {_add} to {rpgSkript::%{_player}%::maxMana} / 40
		else if isWearingMediumOrLess({_player}) is true:
			set {_add} to {rpgSkript::%{_player}%::maxMana} / 70
	else if hasClass({_player}, "cleric") is true:
		set {_add} to {rpgSkript::%{_player}%::maxMana} / 200
	else if hasClass({_player}, "paladin") is true:
		set {_add} to {rpgSkript::%{_player}%::maxMana} / 10
	
	addMana( {_player}, {_add} )

function addMana(player: player, amount: number):
	set {_before} to {rpgSkript::%{_player}%::mana}
	set {rpgSkript::%{_player}%::mana} to {rpgSkript::%{_player}%::mana} + {_amount}
	checkMana({_player})
	if abs( {rpgSkript::%{_player}%::mana} - {_before} ) > 0.01:
		displayMana({_player})

function subMana(player: player, amount: number) :: boolean:
	{_player} has permission "rpg.control":
		return true
	if {rpgSkript::%{_player}%::mana} is not set:
		return false
	if hasMana({_player}, {_amount}) is true:
		set {rpgSkript::%{_player}%::mana} to {rpgSkript::%{_player}%::mana} - {_amount}
		checkMana({_player})
		displayMana({_player})
		return true
	else:
		return false

function hasMana(player: player, amount: number) :: boolean:
	{_player} has permission "rpg.control":
		return true
	# send "&3Mana: Have %{rpgSkript::%{_player}%::mana}%, Need %{_amount}%" to {_player}
	if {rpgSkript::%{_player}%::mana} - {_amount} > -0.01:
		return true
	return false

function displayMana(player: player):
	set {_dispM} to {rpgSkript::%{_player}%::mana}
	if {_dispM} < 0:
		set {_dispM} to 0
	send action bar "&3Mana: %{_dispM}% / %{rpgSkript::%{_player}%::maxMana}%" to {_player}

function hasItems(player: player, items: items) :: boolean:
	{_player} has permission "rpg.control":
		return true
	{_player} has {_items::*}:
		return true
	return false

function takeItems(player: player, items: items) :: boolean:
	{_player} has permission "rpg.control":
		return true
	if hasItems({_player}, {_items}) is true:
		remove {_items::*} from {_player}
		return true
	return false

function hasResources(player: player, mana: number, items: items) :: boolean:
	{_player} has permission "rpg.control":
		return true
	send "&3Items - Need: %{_items::*}%" to {_player}
	if hasItems({_player}, {_items}) is true:
		hasMana({_player}, {_mana}) is true:
			return true
	return false

function takeResources(player: player, mana: number, items: items) :: boolean:
	{_player} has permission "rpg.control":
		return true
	if hasResources({_player}, {_mana}, {_items}) is true:
		remove {_items::*} from {_player}
		subMana({_player}, {_amount})
		return true
	return false

function arcaneSense(message: text):
	loop all players:
		hasClass(loop-player, "wizard") is true:
			send "&d%{_message}%" to loop-player


on death of a player:
    hasClass(victim, "wizard") is true:
        keep the experience
        send "&dYou use your magic powers to keep your experience!" to the victim		

command /imbue <text>:
	description: Imbue an item with powerful magic properties
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if subMana(player, 1000) is false:
			send "&cYou do not have enough mana to imbue an item with magic!"
			stop
		if arg 1 is "health":
			if takeItems( player, (64 glowstone dust and 96 nether wart) ) is true:
				set line lastLoreLine(player's held item) of (player's held item)'s lore to "&cHealth Boost"
				send "&dYou imbue the item in your hand with Health Boost!"
			else:
				send "&cYou do not have the required items for that property! Required: %{_items::*}%"
				stop
		else if arg 1 is "mana":
			if takeItems( player, (4 diamond and 12 gold ingot) ) is true:
				set line lastLoreLine(player's held item) of (player's held item)'s lore to "&3Mana Boost"
				send "&dYou imbue the item in your hand with Mana Boost!"
			else:
				send "&cYou do not have the required items for that property! Required: %{_items::*}%"
				stop
		else:
			send "&cThat is not a valid property!"
			stop

command /arcane <text>:
	description: Send a message to be magically received by wizards
	permission: rpg.control
	permission message: You do not have permission for that command
	trigger:
		arcaneSense(arg 1)

options:
	#chat prefix
	p: &a[Send]
command /send <player>:
	description: Magically send what you are holding to another player!
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if subMana(command executor, 10) is false:
			message "&cYou do not have enough Mana!"
			stop
		set {_senditem} to held item of player
		{_senditem} is not air
		if arg 1 has enough space for {_senditem}:
			remove {_senditem} from player
			give {_senditem} to arg 1
			message "&dSent %{_senditem}% to %arg 1%"
			send "&a[Send] %player% Sent %{_senditem}% to %arg 1%" to console
			send "&dReceived %{_senditem}% from %player%" to arg 1
			delete {_senditem}
		else:
			message "&d%arg 1% does not have enough inventory space!"
			stop

command /remember <text>:
	description: Remember your current location, to recall it later
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if subMana(command executor, 5) is false:
			message "&cYou do not have enough Mana!"
			stop
		if {rpgSkript::%command executor%::memory::%arg 1%} is set:
			message "&cYou already know a location by that name!"
			stop
		set {rpgSkript::%command executor%::memory::%arg 1%} to command executor's location
		message "&dYou take note of your surroundings, so that you may magically return later..."

command /forget <text>:
	description: Forget a location
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		delete {rpgSkript::%command executor%::memory::%arg 1%}
		message "&dYou remove the location from memory..."

command /recall <text>:
	description: Teleport to a location that you remember
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if {rpgSkript::%command executor%::memory::%arg 1%} is set:
			if subMana(command executor, 130) is false:
				message "&cYou do not have enough Mana!"
				stop
			play sound "entity.enderman.teleport" at command executor
			show smoke at command executor
			teleport command executor to {rpgSkript::%command executor%::memory::%arg 1%}
			show smoke at command executor
			play sound "entity.enderman.teleport" at command executor
			message "&dYou recall a location from memory!"
		else:
			message "&dYou do not remember any such location"

command /sendnear <text>:
	description: Teleport nearby players to a location that you remember
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if {rpgSkript::%command executor%::memory::%arg 1%} is set:
			if subMana(command executor, 80) is false:
				message "&cYou do not have enough Mana!"
				stop
			loop entities in radius 7 of player:
				loop-entity is a player
				loop-entity is not command executor
				play sound "entity.enderman.teleport" at loop-entity
				show smoke at loop-entity
				teleport loop-entity to {rpgSkript::%command executor%::memory::%arg 1%}
			message "&dYou send nearby players to a location that you remember!"
		else:
			message "&dYou do not remember any such location"

command /memories:
	description: List locations that you remember
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		loop {rpgSkript::%command executor%::memory::*}:
			message "%loop-index%"

command /pocket:
	description: Open your enderchest
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if subMana(command executor, 20) is false:
			send "&cYou do not have enough Mana to cast the pocket spell!" to command executor
			stop
		send "&dYou open a rift and reach into your enderchest!" to command executor
		make command executor run command "/enderchest" as op

command /cast <text>:
	description: Cast a spell
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if arg 1 is "conjure":
			if subMana(command executor, 1500) is false:
				send "&cYou do not have enough Mana to cast the conjure spell!" to command executor
				stop
			send "&dYou whisper, and an iron golem materializes into existence!" to command executor
			spawn 1 iron golem at the location 1 meter above command executor's targeted block
		if arg 1 is "safe":
			if subMana(command executor, 20) is false:
				send "&cYou do not have enough Mana to cast the magic safe spell!" to command executor
				stop
			set {_inv} to chest inventory with 6 rows named "&dSafe"
			send "&dYou open a rift and reach into a magical safe!" to command executor
			play sound "entity.enderman.teleport" at command executor
			loop 6*9 times:
				set slot (loop-value)-1 of {_inv} to {rpgSkript::%player%::safe::%loop-value%}
			open {_inv} to player
		if arg 1 is "fireball":
			if subMana(command executor, 220) is false:
				send "&cYou do not have enough Mana to cast the fireball spell!" to command executor
				stop
				
			set {_c} to 1
			while {_x} is not set:
				if {rpgSkript::fireballs::%{_c}%} is not set:
					set {_x} to {_c}
					set {rpgSkript::fireballs::%{_x}%} to "fireball"
				else:
					set {_c} to {_c} + 1
					
			set {_loc} to the command executor's location
			set {_loc} to the location 1.6 meters above {_loc}
			
			set {_v} to vector from yaw (yaw of command executor) and pitch (pitch of command executor)
			set {_v} to normalized {_v}
			set the vector length of {_v} to 4
			
			set {_first} to {_v}
			set vector length of {_first} to 4
			
			set {_loc} to ( {_loc} ~ {_first} )
			
			set {rpgSkript::fireballs::%{_x}%::loc} to {_loc}
			set {rpgSkript::fireballs::%{_x}%::v} to {_v}
			set {rpgSkript::fireballs::%{_x}%::time} to now
			set {rpgSkript::fireballs::%{_x}%::caster} to player
			set {rpgSkript::fireballs::%{_x}%} to 1
			play sound "item.firecharge.use" with pitch 0.7 at command executor
			send "&dYou unleash a sphere of fiery destruction!" to command executor

command /fireballs:
	trigger:
		command executor has permission "rpg.control":
			set {_x} to 0
			loop {rpgSkript::fireballs::*}:
				set {_x} to {_x} + 1
			send "&cFireballs: %{_x}%" to command executor

every tick:
	loop {rpgSkript::fireballs::*}:
		set {_loc} to {rpgSkript::fireballs::%loop-index%::loc}

		if difference between {rpgSkript::fireballs::%loop-index%::time} and now is greater than 10 seconds:
			delete {rpgSkript::fireballs::%loop-index%}
		
		y of (vector of {_loc}) is greater than 300:
			explodeFireball(loop-index)
			rpgLog("Cleared stray fireball")
			continue
		y of (vector of {_loc}) is less than -300:
			explodeFireball(loop-index)
			rpgLog("Cleared stray fireball")
			continue
			
		set {_delta} to {rpgSkript::fireballs::%loop-index%::v}
		set vector length of {_delta} to 0.25
		set {_distance} to vector length of {rpgSkript::fireballs::%loop-index%::v}
		while {_distance} > 0.25:
			moveFireball(loop-index, {_delta})
			set {_distance} to {_distance} - 0.25
		set vector length of {_delta} to {_distance}
		moveFireball(loop-index, {_delta})

function moveFireball(index: string, v: vector):
	if {rpgSkript::fireballs::%{_index}%} is not set:
		exit
	show large smoke at ({rpgSkript::fireballs::%{_index}%::loc})
	#broadcast "%{rpgSkript::fireballs::%{_index}%::loc}%"
	set {rpgSkript::fireballs::%{_index}%::loc} to ({rpgSkript::fireballs::%{_index}%::loc} ~ {_v})
	set {_loc} to {rpgSkript::fireballs::%{_index}%::loc}
	#broadcast "%{rpgSkript::fireballs::%{_index}%::loc}%"
	show mob spawner flames at {_loc}
	loop blocks in radius 1 around {_loc}:
		#show mob spawner flames at loop-block
		loop-block is water:
			delete {rpgSkript::fireballs::%{_index}%}
		loop-block is solid:
			explodeFireball({_index})
	loop all entities in radius 2 around {_loc}:
		loop-entity is not a dropped item:
			explodeFireball({_index})

function explodeFireball(index: string):
	if {rpgSkript::fireballs::%{_index}%} is not set:
		exit
	set {_loc} to {rpgSkript::fireballs::%{_index}%::loc}
	playSoundToPlayers({_loc}, "entity.firework_rocket.blast", 90, 0.3)
	explodeRadius(block at {_loc}, 1.5)
	loop blocks in radius 2.5 around {_loc}:
		loop-block is air:
			show mob spawner flames at loop-block
	delete {rpgSkript::fireballs::%{_index}%}
	loop all entities in radius 8 around ({_loc}):
		loop-entity is not a dropped item
		damage loop-entity by 60
	create an explosion with force 3 at {_loc}
	if {rpgSkript::fireballs::%{_index}%::caster} is set:
		add 5 experience to {rpgSkript::fireballs::%{_index}%::caster}

every tick:
	loop {rpgSkript::cryoballs::*}:
		set {_loc} to {rpgSkript::cryoballs::%loop-index%::loc}

		if difference between {rpgSkript::cryoballs::%loop-index%::time} and now is greater than 10 seconds:
			delete {rpgSkript::cryoballs::%loop-index%}
		
		y of (vector of {_loc}) is greater than 300:
			explodeCryoball(loop-index)
			rpgLog("Cleared stray cryoball")
			continue
		y of (vector of {_loc}) is less than -300:
			explodeCryoball(loop-index)
			rpgLog("Cleared stray cryoball")
			continue
			
		set {_delta} to {rpgSkript::cryoballs::%loop-index%::v}
		set vector length of {_delta} to 0.25
		set {_distance} to vector length of {rpgSkript::cryoballs::%loop-index%::v}
		while {_distance} > 0.25:
			moveCryoball(loop-index, {_delta})
			set {_distance} to {_distance} - 0.25
		set vector length of {_delta} to {_distance}
		moveCryoball(loop-index, {_delta})
		set {rpgSkript::cryoballs::%loop-index%::v} to {rpgSkript::cryoballs::%loop-index%::v} -- (vector 0,0.1,0)

function moveCryoball(index: string, v: vector):
	if {rpgSkript::cryoballs::%{_index}%} is not set:
		exit
	set {rpgSkript::cryoballs::%{_index}%::loc} to ({rpgSkript::cryoballs::%{_index}%::loc} ~ {_v})
	set {_loc} to {rpgSkript::cryoballs::%{_index}%::loc}
	show water splash at {_loc}
	loop blocks in radius 1 around {_loc}:
		show cloud at loop-block
		show water splash at {_loc}
		loop-block is water:
			explodeCryoball({_index})
		loop-block is lava:
			explodeCryoball({_index})
		loop-block is solid:
			explodeCryoball({_index})
	loop all entities in radius 2 around {_loc}:
		loop-entity is not a dropped item:
			explodeCryoball({_index})

function explodeCryoball(index: string):
	if {rpgSkript::cryoballs::%{_index}%} is not set:
		exit
	set {_loc} to {rpgSkript::cryoballs::%{_index}%::loc}
	playSoundToPlayers({_loc}, "entity.firework_rocket.blast", 50, 0.7)
	loop blocks in radius 4 around {_loc}:
		loop-block is air:
			show cloud at loop-block
		loop-block is water:
			set loop-block to ice
		loop-block is lava:
			set loop-block to cobblestone
	delete {rpgSkript::cryoballs::%{_index}%}
	loop all entities in radius 14 around ({_loc}):
		loop-entity is not a dropped item
		damage loop-entity by 3
		apply slowness 3 to loop-entity for 8 seconds replacing the existing effect
	if {rpgSkript::cryoballs::%{_index}%::caster} is set:
		add 3 experience to {rpgSkript::cryoballs::%{_index}%::caster}

on inventory close:
	if event-inventory's name is "&dSafe":
		loop 6*9 times:
			set {rpgSkript::%player%::safe::%loop-value%} to slot (loop-value)-1 of event-inventory

on right click with stick:
	player's held item is not a plain stick:
		stop trigger
	hasClass(player, "wizard") is true
	if subMana(event-player, 5) is false:
		send "&cYou do not have enough Mana to cast the firebolt spell!" to event-player
		stop
	send "&dYou hurl a mote of fire!" to event-player
	play sound "item.firecharge.use" at event-player
	make player run command "/fireball" as op
	add 2 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)

on right click with gunpowder:
	hasClass(player, "wizard") is true
	if subMana(event-player, 100) is false:
		send "&cYou do not have enough Mana to cast the explosion spell!" to event-player
		stop
	send "&dYou speak words of arcane significance and create a powerful explosion!" to event-player
	play sound "item.firecharge.use" at event-player
	loop all entities in radius 8 around (event-player's targeted block):
		loop-entity is not a dropped item
		damage loop-entity by 24
		add 4 experience to the player
	create an explosion with force 5 at the event-player's targeted block
	add 10 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)

on right click with nether quartz:
	hasClass(player, "wizard") is true
	if subMana(event-player, 200) is false:
		send "&cYou do not have enough Mana to cast the smite spell!" to event-player
		stop
	send "&dYou strike monsters with lightning!" to event-player
	play sound "entity.player.breath" with pitch 0.7 at player
	loop all entities in radius 12 around (event-player's targeted block):
		loop-entity is not a dropped item
		loop-entity is not a player
		isMonster(loop-entity) is true
		loop-entity's health is greater than 0
		create lightning effect at the loop-entity
		damage loop-entity by 8
		add 5 experience to the player
	add 14 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)

on right click with iron nugget:
	hasClass(player, "wizard") is true
	if subMana(event-player, 180) is false:
		send "&cYou do not have enough Mana to cast the shatter spell!" to event-player
		stop
	send "&dYou tear at the fabric of reality!" to event-player
	play sound "item.firecharge.use" at event-player
	loop all blocks in radius 15 around (event-player's targeted block):
		chance of 0.3%:
			loop-block is not air
			create an explosion with force 3 at the loop-block
			wait 1 ticks
	#create an explosion with force 5 at the event-player's targeted block
	add 10 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)

on right click with magma cream:
	hasClass(player, "wizard") is true
	make player execute command "/cast fireball"

on right click with flint:
	hasClass(player, "wizard") is true
	if subMana(event-player, 18) is false:
		send "&cYou do not have enough Mana to cast the ignite spell!" to event-player
		stop
	send "&dYou draw energy from the item in your hand and light creatures on fire!" to event-player
	play sound "item.flintandsteel.use" at event-player
	loop all entities in radius 13 around (event-player's targeted block):
		loop-entity is not a dropped item
		loop-entity is not player
		ignite loop-entity for 10 seconds
		show mob spawner flames at (the location 1 block above the loop-entity's location)
		add 1 experience to the player
	add 4 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)

on right click with blaze rod:
	hasClass(player, "wizard") is true
	if subMana(event-player, 1000) is false:
		send "&cYou do not have enough Mana to cast the devastating blast spell!" to event-player
		stop
	send "&dYou shout, and your thunderous words are met with an equally powerful blast of destruction!" to event-player
	set {_block} to event-player's targeted block
	play sound "item.firecharge.use" at event-player
	loop all entities in radius 50 around {_block}:
		loop-entity is not a dropped item
		loop-entity is not the player
		set {_vec} to the vector between {_block} and the loop-entity
		set {_vec} to normalized {_vec}
		push loop-entity {_vec} with force 2
		damage loop-entity by 200
		add 16 experience to the player
	create an explosion with force 0 at {_block}
	explodeRadius({_block}, 13)
	wait 5 ticks
	create an explosion with force 38 at {_block}
	add 32 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)
	create a fake explosion at the player

on right click with diamond:
	hasClass(player, "wizard") is true
	if subMana(event-player, 300) is false:
		send "&cYou do not have enough Mana to cast the lightning spell!" to event-player
		stop
	send "&dYou conjure an enormous bolt of lighting from the heavens!" to event-player
	if isLightningRodWithinRangeOf(location of event-player's targeted block, 150, true) is true:
		send "&dYou sense that your lightning as been absorbed by a lightning rod!"
		stop
	loop all entities in radius 22 around (event-player's targeted block):
		loop-entity is not a dropped item
		loop-entity is not the player
		damage loop-entity by 90
		add 12 experience to the player
	create lightning effect at the event-player's targeted block
	create an explosion with force 12 at the event-player's targeted block
	add 24 experience to the player
	play sound "entity.player.breath" with pitch 0.7 at player

on right click with feather:
	hasClass(player, "wizard") is true
	set {_t} to targeted entity of player
	{_t} is a player:
		if subMana(event-player, 90) is false:
			send "&cYou do not have enough Mana to cast the heal other spell!" to event-player
			stop
		heal({_t}, 3)
		send "&dYou heal %{_t}%!" to event-player
		send "&dYou are healed!" to {_t}
		play sound "entity.player.levelup" with pitch 1.5 at {_t}
		stop
	if subMana(event-player, 90) is false:
		send "&cYou do not have enough Mana to cast the heal spell!" to event-player
		stop
	heal(event-player, 3)
	send "&dYou are healed!" to event-player
	play sound "entity.player.levelup" with pitch 1.5 at event-player

on right click with amethyst shard:
	hasClass(player, "wizard") is true
	set {_loc} to event-player's targeted block
	set {_loc} to location 1 meter above {_loc}
	set pitch of {_loc} to pitch of event-player
	set yaw of {_loc} to yaw of event-player

	set {_canTp} to true
	if block at {_loc} is solid:
		set {_canTp} to false
	if block 1 meter above {_loc} is solid:
		set {_canTp} to false
	if {_canTp} is false:
		send "&cCannot blink there!" to event-player
		stop
		
	if subMana(event-player, 80) is false:
		send "&cYou do not have enough Mana to cast the blink spell!" to event-player
		stop
	send "&dYou blink to your target location!" to event-player
	play sound "entity.enderman.teleport" at event-player
	teleport event-player to {_loc}
	add 1 experience to the event-player
	wait 2 ticks
	play sound "entity.enderman.teleport" at event-player

on right click with clay ball:
	hasClass(player, "wizard") is true
	if subMana(event-player, 50) is false:
		send "&cYou do not have enough Mana to cast the move monsters spell!" to event-player
		stop
	send "&dSummoned nearby monsters near where you are looking!" to event-player
	set {_loc} to event-player's targeted block
	loop all entities in radius 60 around (event-player's targeted block):
		loop-entity is not a dropped item
		loop-entity is not a player
		teleport loop-entity to location 1 meter above {_loc}
		add 1 experience to the player
	add 2 experience to the player
	play sound "entity.player.breath" with pitch 0.7 at player

on right click with sugar:
	hasClass(player, "wizard") is true
	if subMana(event-player, 30) is false:
		send "&cYou do not have enough Mana to cast the move items spell!" to event-player
		stop
	send "&dSummoned nearby dropped items near where you are looking!" to event-player
	set {_loc} to event-player's targeted block
	loop all entities in radius 80 around (event-player's targeted block):
		loop-entity is a dropped item
		teleport loop-entity to location 1 meter above {_loc}
		add 1 experience to the player
	add 2 experience to the player
	play sound "entity.player.breath" with pitch 0.7 at player

on right click with wheat:
	hasClass(player, "wizard") is true
	if subMana(event-player, 200) is false:
		send "&cYou do not have enough Mana to cast the harvest spell!" to event-player
		stop
	send "&dYou wave your hands and your crops have been magically harvested!" to event-player
	loop blocks in radius 50 of player:
		set {_loc} to location of loop-block
		loop-block is wheat:
			break loop-block naturally
			set loop-block to wheat
			wait 2 ticks
		loop-block is carrot plant:
			break loop-block naturally
			set loop-block to carrot plant
			wait 2 ticks
		loop-block is potato plant:
			break loop-block naturally
			set loop-block to potato plant
			wait 2 ticks
		loop-block is nether wart plant:
			break loop-block naturally
			set loop-block to nether wart plant
			wait 2 ticks
		loop-block is melon:
			break loop-block naturally
			wait 2 ticks
		loop-block is pumpkin:
			break loop-block naturally
			wait 2 ticks
		loop-block is bamboo:
			block 1 meter below loop-block is bamboo
			break loop-block naturally
			wait 2 ticks
		loop-block is sugar cane:
			block 1 meter below loop-block is sugar cane
			break loop-block naturally
			wait 2 ticks
		loop-block is sweet berry bush:
			loop-block's age is 3
			set loop-block's age to 1
			drop 3 sweet berry at {_loc}
			wait 2 ticks

command /wizardresearch:
	executable by: players
	trigger:
		hasClass(player, "wizard") is false:
			send "&dYou are not a wizard!"
			exit
		set {_menu} to a new chest inventory with 6 rows named "&dWizard Research"
		
		populateWizardResearchMenu(player, {_menu})
		
		open {_menu} to player

function populateWizardResearchMenu(player: player, menu: inventory):
	set {_item} to red wool named "&7Constant Study"
	if hasResearch({_player}, "power") is true:
		set {_item} to lime wool named "&eConstant Study"
	set line 1 of {_item}'s lore to "&6Gain 3 experience every 2 seconds"
	set slot 31 of {_menu} to {_item}

on inventory click:
	name of event-inventory is "&dWizard Research"
	cancel event
	
	if index of event-slot is 31:
		if hasResearch(player, "power") is true:
			deleteResearch(player, "power")
		else:
			addResearch(player, "power")

	populateWizardResearchMenu(player, event-inventory)

on right click with lapis lazuli:
	hasClass(player, "wizard") is true
	if subMana(command executor, 60) is false:
		send "&cYou do not have enough Mana to cast the cryoball spell!" to command executor
		stop
		
	set {_c} to 1
	while {_x} is not set:
		if {rpgSkript::cryoballs::%{_c}%} is not set:
			set {_x} to {_c}
			set {rpgSkript::cryoballs::%{_x}%} to "cryoball"
		else:
			set {_c} to {_c} + 1
			
	set {_loc} to the command executor's location
	set {_loc} to the location 1.6 meters above {_loc}
	
	set {_v} to vector from yaw (yaw of command executor) and pitch (pitch of command executor)
	set {_v} to normalized {_v}
	set the vector length of {_v} to 2
	
	set {_first} to {_v}
	set vector length of {_first} to 4
	
	set {_loc} to ( {_loc} ~ {_first} )
	
	set {rpgSkript::cryoballs::%{_x}%::loc} to {_loc}
	set {rpgSkript::cryoballs::%{_x}%::v} to {_v}
	set {rpgSkript::cryoballs::%{_x}%::time} to now
	set {rpgSkript::cryoballs::%{_x}%::caster} to player
	set {rpgSkript::cryoballs::%{_x}%} to 1
	play sound "item.bucket.empty" with pitch 0.7 at command executor
	send "&dYou release a freezing orb of water!" to command executor
