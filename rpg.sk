# General

Options:
	prefix: &c[&eRPG Skript&c]&r
	consolePrefix: &6[&8Console&6]&r

	debugPrefix: &e[&bDEBUG&e]&r
	debug: true

	benchmark: false
	benchmarkSpan: 10 seconds

	drawRadius: 20

	itemsOnPage: 9

on script load:
	scriptBroadcast("Loading script...")
	scriptDebugBroadcast("Debug Output Enabled")

	scriptConsoleMessage("Test console message")
	scriptDebugConsoleMessage("Test debug to console")

on script unload:
	broadcast "{@prefix} &3Unloading script..."

	delete {-rpgSkript::fireballs::*}
	delete {-rpgSkript::cryoballs::*}

	loop {-rpgSkript::minions::*}:
		killMinion(loop-index)

	delete {-rpgSkript::minions::*}
	delete {-rpgSkript::effects::*}
	delete {-rpgSkript::worldeffects::*}

on join:
	wait 3 seconds
	send "&c-------- &eMinecraft RPG &c--------" to player
	send "&l&eNew&r&e:" to player

	# Example: send "&3 - <stuff>" to player

	send "&3 - New Class: Paladin. Evil falters in their presence!" to player
	send "&3 - New Class: Necromancer. Command the undead to do your bidding" to player
	send "&3 - New Class: Endwarden. Tap into the power of the void to massacre your enemies!" to player
	send "&3 - New Class: Barbarian. Use a new type of energy 'Rage' in order to tank and obliterate your enemies!" to player
	send "&3 - New Class: Druid. Protect the Natural Order with your skills and a trusty companion!" to player
	send "&3 - New Class: Cleric. Channel divine powers to smite your foes!" to player
	send "&3 - New Class: Artificer. Manipulate magic and technology!" to player

	send "&3 - Items can now be imbued to grant classes while you are wearing/holding them" to player
	send "&3 - Warrior no longer gets slowness when they take damage" to player

	#send "&3" to player

	send "&c-------- &eMinecraft RPG &c--------" to player


on chat:
	set the message to "&6[&8LVL %player's level%&6]&r %message%"

	loop getClassList():
		hasClass(player, loop-value) is true:
			set the message to "%getClassNamePlate(loop-value)% %message%"

function getClassList() :: texts:
	add "wizard" to {_classes::*}
	add "rogue" to {_classes::*}
	add "warrior" to {_classes::*}
	add "paladin" to {_classes::*}
	add "cleric" to {_classes::*}
	add "artificer" to {_classes::*}
	add "necromancer" to {_classes::*}
	add "druid" to {_classes::*}
	add "sorceror" to {_classes::*}
	add "endwarden" to {_classes::*}
	add "barbarian" to {_classes::*}

	add "herobrine" to {_classes::*}

	return {_classes::*}

function getClassNamePlate(name: text) :: text:
	{_name} is "rogue":
		return "&7[&2Rogue&7]&r"
	{_name} is "warrior":
		return "&e[&cWarrior&e]&r"
	{_name} is "wizard":
		return "&8[&3Wizard&8]&r"
	{_name} is "paladin":
		return "&6[&9Paladin&6]&r"
	{_name} is "cleric":
		return "&3[&eCleric&3]&r"
	{_name} is "sorceror":
		return "&e[&cSorceror&e]&r"
	{_name} is "necromancer":
		return "&c[&7Necromancer&c]&r"
	{_name} is "herobrine":
		return "&0[&4Herobrine&0]&r"
	{_name} is "barbarian":
		return "&c[&4Barbarian&c]&r"
	{_name} is "endwarden":
		return "&0[&9Endwarden&0]&r"
	{_name} is "druid":
		return "&6[&aDruid&6]&r"
	{_name} is "artificer":
		return "&7[&bArtificer&7]&r"

	return "&r[%{_name} in lower case%]&r"

function getClassDescription(name: text) :: text:
	return "No description has been written."

command /listclasses <integer=1>:
	trigger:
		loop getClassList():
			if featureEnabled("g_%loop-value%_class") is false:
				set {_prefix} to "&cD &4- &r"
			else:
				set {_prefix} to "&aE &2- &r"

			add "%{_prefix}%%getClassNamePlate(loop-value)% &b- &e%getClassDescription(loop-value)%" to {_nameplates::*}

		set {_lines::*} to paginate({_nameplates::*}, arg 1)

		loop {_lines::*}:
			send "%loop-value%" to command executor

function paginate(lines: texts, page: integer, perPage: integer={_none}) :: texts:
	{_perPage} is not set:
		set {_perPage} to {@itemsOnPage}

	set {_count} to countLines({_lines::*})
	set {_pages} to ceil( {_count} / {_perPage} )

	set {_starting} to ({_page} - 1) * {_perPage}
	set {_ending} to {_starting} + {_perPage} - 1
	set {_index} to 0

	add "&b ------- Page %{_page}% / %{_pages}% -------" to {_toRet::*}

	{_page} < 1:
		return {_toRet::*}
	{_page} > {_pages}:
		return {_toRet::*}

	loop {_lines::*}:
		if {_index} >= {_starting}:
			if {_index} <= {_ending}:
				add loop-value to {_toRet::*}
		add 1 to {_index}

	return {_toRet::*}

function countLines(lines: texts) :: number:
	set {_toRet} to 0
	loop {_lines::*}:
		add 1 to {_toRet}
	return {_toRet}

command /view <player> <string>:
	trigger:
		command executor is a player:
			player doesn't have permission "rpg.control":
				send "&cYou do not have permission to run that command!" to command executor
				stop

		arg 2 is "equip" or "equipment":
			send "&b---- &e%arg 1%'s Equipment &b----" to command executor
			send "&eHelmet&b: &a%arg 1's helmet%&b, &eEnchantments&b: &a%enchantments of arg 1's helmet%" to command executor
			send "&eChestplate&b: &a%arg 1's chestplate%&b, &eEnchantments&b: &a%enchantments of arg 1's chestplate%" to command executor
			send "&eLeggings&b: &a%arg 1's leggings%&b, &eEnchantments&b: &a%enchantments of arg 1's leggings%" to command executor
			send "&eBoots&b: &a%arg 1's boots%&b, &eEnchantments&b: &a%enchantments of arg 1's boots%" to command executor
			send "&eHeld Item&b: &a%arg 1's held item%&b, &eEnchantments&b: &a%enchantments of arg 1's held item%" to command executor
			send "&eOffhand Item&b: &a%arg 1's offhand item%&b, &eEnchantments&b: &a%enchantments of arg 1's offhand item%" to command executor
		else if arg 2 is "stat" or "stats":
			send "&b---- &e%arg 1%'s Stats &b----" to command executor
			send "&eHealth&b: &a%arg 1's health% / %arg 1's max health%" to command executor
			send "&eMana&b: &a%{rpgSkript::mana::%arg 1%}% / %{rpgSkript::maxMana::%arg 1%}%" to command executor
			send "&eMinions&b: &a%getMinionCount(arg 1)% / %calculateMaxMinions(arg 1)%" to command executor
			send "&eWildshape&b: &a%{rpgSkript::%arg 1%::wildshape}% / %{rpgSkript::%arg 1%::maxWildshape}%" to command executor
			send "&eRage&b: &a%{rpgSkript::%arg 1%::rage}% / %{rpgSkript::%arg 1%::maxRage}%" to command executor
		else:
			send "&cInvalid data!" to command executor
			send "&cYou may view 'equipment' or 'stats'" to command executor

function rpgLog(message: text):
	log "%{_message}%" to "rpg/main.log"

function scriptBroadcast(message: text):
	broadcast "{@prefix} &3%{_message}%"

function scriptConsoleMessage(message: text):
	send "{@consolePrefix} {@prefix} &3%{_message}%" to console

function shouldPrintDebugType(type: string) :: boolean:
	if {rpgSkript::debug::%{_type}%} is not set:
		set {rpgSkript::debug::%{_type}%} to false
	return {rpgSkript::debug::%{_type}%}

function scriptDebugBroadcast(message: text):
	scriptDebugBroadcastType("main", {_message})

function scriptDebugBroadcastType(type: string, message: text):
	{@debug} is true:
		shouldPrintDebugType({_type}) is true:
			broadcast "{@debugPrefix} {@prefix} &f%{_type}% &7%{_message}%"

function scriptDebugConsoleMessage(message: text):
	scriptDebugConsoleMessageType("main", {_message})

function scriptDebugConsoleMessageType(type: string, message: text):
	{@debug} is true:
		shouldPrintDebugType({_type}) is true:
			send "{@consolePrefix} {@debugPrefix} {@prefix} &f%{_type}% &7%{_message}%" to console

command /rpgannounce <string>:
	trigger:
		command executor has permission "rpg.control"
		scriptBroadcast("&cAnnouncement: &e%arg 1%")

command /rpgdebug <string> <boolean>:
	trigger:
		command executor has permission "rpg.control"
		set {rpgSkript::debug::%arg 1%} to arg 2
		send "&3Debug logging changed" to command executor

command /rpgdebugged <integer=1>:
	trigger:
		command executor has permission "rpg.control"

		loop {rpgSkript::debug::*}:
			add "&3%loop-index% -> %loop-value%" to {_debuggedLines::*}

		set {_lines::*} to paginate({_debuggedLines::*}, arg 1)

		loop {_lines::*}:
			send loop-value to command executor

command /rpgdebugreset:
	trigger:
		command executor has permission "rpg.control"
		delete {rpgSkript::debug::*}
		send "&cEnabled debug types reset" to command executor

function benchmark(type: string):
	{@benchmark} is true
	{-rpgSkript::benchmark::%{_type}%} is not set:
		set {-rpgSkript::benchmark::%{_type}%} to false

	{-rpgSkript::benchmark::%{_type}%} is true

	{-rpgSkript::benchmark::%{_type}%::last} is not set:
		set {-rpgSkript::benchmark::%{_type}%::last} to now
	{-rpgSkript::benchmark::%{_type}%::runs} is not set:
		set {-rpgSkript::benchmark::%{_type}%::runs} to 0

	add 1 to {-rpgSkript::benchmark::%{_type}%::runs}
	set {_difference} to difference between {-rpgSkript::benchmark::%{_type}%::last} and now

	{_difference} is more than {@benchmarkSpan}:
		scriptBroadcast("%{_type}% - %{-rpgSkript::benchmark::%{_type}%::runs}% runs over %{_difference}%")
		set {-rpgSkript::benchmark::%{_type}%::last} to now
		set {-rpgSkript::benchmark::%{_type}%::runs} to 0

command /rpgbench <string> <boolean>:
	trigger:
		command executor has permission "rpg.control"
		set {-rpgSkript::benchmark::%arg 1%} to arg 2
		delete {-rpgSkript::benchmark::%arg 1%::*}
		arg 2 is true:
			send "&3Running benchmark %arg 1%" to command executor
		arg 2 is false:
			send "&3Disabling benchmark %arg 1%" to command executor

command /rpgbenched:
	trigger:
		command executor has permission "rpg.control"
		loop {-rpgSkript::benchmark::*}:
			send "&3%loop-index% -> %loop-value%" to command executor

command /rpgbenchreset:
	trigger:
		command executor has permission "rpg.control"
		delete {-rpgSkript::benchmark::*}
		send "&cEnabled benchmark types reset" to command executor

command /rpgflag <string> <boolean>:
	trigger:
		command executor has permission "rpg.control"
		set {_flag} to arg 1 in lowercase
		set {rpgSkript::feature_flags::%{_flag}%} to arg 2
		send "&3Flag set: %{_flag}% -> %arg 2%" to command executor

command /rpgflags <integer=1>:
	trigger:
		command executor has permission "rpg.control"

		loop {rpgSkript::feature_flags::*}:
			add "&3%loop-index% -> %loop-value%" to {_flagLines::*}

		set {_lines::*} to paginate({_flagLines::*}, arg 1)

		loop {_lines::*}:
			send loop-value to command executor

command /rpgflagreset:
	trigger:
		command executor has permission "rpg.control"
		delete {rpgSkript::feature_flags::*}
		send "&dFeature flags reset" to command executor

function featureEnabled(name: string) :: boolean:
	replace all " " with "_" in {_name}
	if {rpgSkript::feature_flags::%{_name}%} is not set:
		set {rpgSkript::feature_flags::%{_name}%} to true
	return {rpgSkript::feature_flags::%{_name}%}

function giveItem(player: player, item: item) :: boolean:
	{_player} doesn't have space for {_item}:
		send "&cYou don't have space for %{_item}%" to {_player}
		scriptConsoleMessage("Failed to give %{_item}% to %{_player}%")
		return false
	give {_item} to {_player}
	send "&aYou receive %{_item}%" to {_player}
	scriptConsoleMessage("Gave %{_item}% to %{_player}%")
	return true

function getPlayerLevel(player: player) :: integer:
	return level of {_player}

function hasClass(player: player, class: text) :: boolean:
	if featureEnabled("classes") is false:
		return false
	if featureEnabled("g_%{_class}%_class") is false:
		return false
	if {_class} is not in getClassList():
		return false
	if {_player} has permission "rpg.%{_class}%":
		return true
	if featureEnabled("class_from_imbue") is true:
		if hasImbue({_player}, "%{_class}% class") is true:
			return true
	return false

function isMonster(entity: entity) :: boolean:
	{_entity} is a player:
		hasClass({_entity}, "herobrine") is true:
			return true
	isMinion({_entity}) is true:
		return false
	{_entity} is a monster:
		return true
	{_entity} is a phantom:
		return true
	{_entity} is a hoglin:
		return true
	{_entity} is a shulker:
		return true
	{_entity} is a magma slime:
		return true
	return false

function setMaxHealth(player: player):
	set {_newMax} to 10
	if hasClass({_player}, "herobrine") is true:
		set {_newMax} to 40
	else if hasClass({_player}, "warrior") is true:
		set {_newMax} to 20
	else if hasClass({_player}, "barbarian") is true:
		set {_newMax} to 15
	else if hasClass({_player}, "druid") is true:
		set {_newMax} to 15
	else if hasClass({_player}, "wizard") is true:
		set {_newMax} to 8
	else if hasClass({_player}, "sorceror") is true:
		set {_newMax} to 8
	else if hasClass({_player}, "endwarden") is true:
		set {_newMax} to 8
	else:
		set {_newMax} to 10

	hasClass({_player}, "warrior") is true:
		if hasResearch({_player}, "durable") is true:
			set {_newMax} to {_newMax} * 1.25

	hasClass({_player}, "druid") is true:
		sun light level at {_player} is greater than 5:
			set {_newMax} to {_newMax} * 1.20

		if {rpgSkript::%{_player}%::batshape} is true:
			set {_newMax} to 0.25 * {_newMax} 
		else if {rpgSkript::%{_player}%::wolfshape} is true:
			set {_newMax} to 1.0 * {_newMax}
		else if {rpgSkript::%{_player}%::horseshape} is true:
			set {_newMax} to 1.3 * {_newMax}
		else if {rpgSkript::%{_player}%::spidershape} is true:
			set {_newMax} to 0.9 * {_newMax} 
		else if {rpgSkript::%{_player}%::bearshape} is true:
			set {_newMax} to 2.5 * {_newMax}

	if hasImbue({_player}, "Health Boost") is true:
		set {_newMax} to ({_newMax} + {_newMax} * 0.15 * countImbue({_player}, "Health Boost"))

	if hasImbue({_player}, "golem") is true:
		set {_newMax} to {_newMax} * 1.2

	hasImbue({_player}, "photosynthesis") is true:
		sun light level at {_player} is greater than 13:
			time in world of {_player} is not between 19:00 and 5:00:
				set {_newMax} to {_newMax} * ( 1 + 0.1 * countImbue({_player}, "photosynthesis") )

	hasEffect({_player}, "disease") is true:
		set {_newMax} to {_newMax} * 0.8

	set {_newMax} to ceil({_newMax})
	if {_player}'s maximum health is not {_newMax}:
		set {_player}'s maximum health to {_newMax}
		send "&cYour maximum health has changed to %{_newMax}% hearts" to {_player}

function canFly(player: player):: boolean:
	if {rpgSkript::%{_player}%::batshape} is true:
		return true
	if {_player}'s gamemode is not survival:
		return true
	if hasClass({_player}, "herobrine") is true:
		return true
	return false

function getItemCostForImbue(imbue: text):: items:

	# Artificer

	if {_imbue} is "vampiric":
		return (8 copper ingot and 16 redstone)
	else if {_imbue} is "hallowed":
		return (32 quartz and 3 diamond)
	else if {_imbue} is "shocking":
		return (32 lapis lazuli and 16 copper ingot)
	else if {_imbue} is "bleeding":
		return (8 iron ingot and 12 copper ingot)
	else if {_imbue} is "mana leak":
		return (24 lapis lazuli and 24 quartz and 4 diamond)
	else if {_imbue} is "golem":
		return (64 cobblestone and 12 iron ingot)
	else if {_imbue} is "flame shield":
		return (8 flint and 16 gold ingot)
	else if {_imbue} is "mana shield":
		return (24 lapis lazuli and 24 redstone and 4 diamond)
	else if {_imbue} is "excavation":
		return (8 gold ingot and 12 copper ingot)
	else if {_imbue} is "repulsor":
		return (32 quartz and 32 copper ingot)
	else if {_imbue} is "firststrike":
		return (4 diamond and 32 quartz)
	else if {_imbue} is "detonate":
		return (48 redstone and 16 copper ingot and 16 gunpowder)
	else if {_imbue} is "Frost Shield":
		return (4 diamond and 32 copper ingot)
	else if {_imbue} is "Iron Will":
		return (48 iron ingot and 24 copper ingot and 2 netherite ingot)

	# Wizard

	else if {_imbue} is "health":
		return (96 nether wart and 64 glowstone dust)
	else if {_imbue} is "mana":
		return (2 diamond and 6 gold ingot)
	else if {_imbue} is "siphon":
		return (2 diamond and 48 quartz)
	else if {_imbue} is "Enlighten":
		return (64 lapis lazuli and 64 quartz and 4 diamond)

	# Druid

	else if {_imbue} is "Photosynthesis":
		return (24 lapis lazuli and 24 quartz and 4 diamond)

command /ingredients <text>:
	executable by: players
	trigger:
		set {_cost::*} to getItemCostForImbue(arg 1)
		{_cost::*} is set:
			send "&e%arg 1 in lower case% costs: %{_cost::*}%" to the player
		else:
			send "&cNot a valid imbuement" to the player

function lastLoreLine(item: item) :: number:
	set {_x} to 1
	loop lore of {_item}:
		set {_x} to {_x} + 1
	return {_x}

function hasAnyImbue(item: item) :: boolean:
	if lastLoreLine({_item}) is 1:
		return false
	return true

function addImbue(item: item, imbue: text) :: item:
	set line lastLoreLine({_item}) of ({_item})'s lore to {_imbue}
	scriptDebugBroadcastType("imbue", "%{_item}% imbue %{_imbue}%")
	return {_item}

function countImbue(player: player, text: text) :: number:
	if featureEnabled("g_%{_text}%_imbue") is false:
		return 0

	set {_c} to 0
	if hasLore({_player}'s helmet, {_text}) is true:
		set {_c} to {_c} + 1
	if hasLore({_player}'s chestplate, {_text}) is true:
		set {_c} to {_c} + 1
	if hasLore({_player}'s leggings, {_text}) is true:
		set {_c} to {_c} + 1
	if hasLore({_player}'s boots, {_text}) is true:
		set {_c} to {_c} + 1
	if hasLore({_player}'s held item, {_text}) is true:
		set {_c} to {_c} + 1
	if hasLore({_player}'s off hand item, {_text}) is true:
		set {_c} to {_c} + 1
	return {_c}

function hasImbue(player: player, text: text) :: boolean:
	if featureEnabled("g_%{_text}%_imbue") is false:
		return false

	if hasLore({_player}'s helmet, {_text}) is true:
		return true
	if hasLore({_player}'s chestplate, {_text}) is true:
		return true
	if hasLore({_player}'s leggings, {_text}) is true:
		return true
	if hasLore({_player}'s boots, {_text}) is true:
		return true
	if hasLore({_player}'s held item, {_text}) is true:
		return true
	if hasLore({_player}'s off hand item, {_text}) is true:
		return true
	return false

function hasLore(item: item, text: text) :: boolean:
	loop lore of {_item}:
		if loop-value contains {_text}:
			return true
	return false

function isWearingNothing(player: player) :: boolean:
	helmet of {_player} is not (air):
		return false
	chestplate of {_player} is not (air):
		return false
	leggings of {_player} is not (air):
		return false
	boots of {_player} is not (air):
		return false
	off hand item of {_player} is shield:
		return false
	return true

function isWearingLightOrLess(player: player) :: boolean:
	hasLore(helmet of {_player}, "light") is false:
		helmet of {_player} is not (leather helmet or air):
			return false
	hasLore(chestplate of {_player}, "light") is false:
		chestplate of {_player} is not (leather chestplate or air):
			return false
	hasLore(leggings of {_player}, "light") is false:
		leggings of {_player} is not (leather leggings or air):
			return false
	hasLore(boots of {_player}, "light") is false:
		boots of {_player} is not (leather boots or air):
			return false
	hasLore(off hand item of {_player}, "light") is false:
		off hand item of {_player} is shield:
			return false
	return true

function isWearingMediumOrLess(player: player) :: boolean:
	if isWearingLightOrLess({_player}) is true:
		return true
	hasLore(helmet of {_player}, "light") is false:
		helmet of {_player} is (diamond helmet or netherite helmet):
			return false
	hasLore(chestplate of {_player}, "light") is false:
		chestplate of {_player} is (diamond chestplate or netherite chestplate):
			return false
	hasLore(leggings of {_player}, "light") is false:
		leggings of {_player} is (diamond leggings or netherite leggings):
			return false
	hasLore(boots of {_player}, "light") is false:
		boots of {_player} is (diamond boots or netherite boots):
			return false
	return true

function isWearingHeavyOrLess(player: player) :: boolean:
	return true

function concatStringList(list: texts, delim: string=" ") :: text:
	set {_toRet} to ""
	set {_first} to true

	loop {_list::*}:
		if {_first} is true:
			set {_toRet} to "%loop-value%"
			set {_first} to false
		else:
			set {_toRet} to "%{_toRet}%%{_delim}%%loop-value%"

	return {_toRet}

function shouldTriggerAbility(player: player) :: boolean:
	if at least one of:
		{_player}'s targeted block's inventory is set
		{_player}'s targeted block is a crafting table
		{_player}'s targeted block is an enchanting table
		{_player}'s targeted block is an ender chest
		{_player}'s targeted block is a brewing stand
		{_player}'s targeted block is a fletching table
		{_player}'s targeted block is a cartography table
		{_player}'s targeted block is a smithing table
		{_player}'s targeted block is a grindstone
		{_player}'s targeted block is a stonecutter
		{_player}'s targeted block is a loom
		{_player}'s targeted block is a jukebox
		{_player}'s targeted block is a note block
		{_player}'s targeted block is a lectern
		{_player}'s targeted block is a bell
		{_player}'s targeted block is any bed
		{_player}'s targeted block is any door
		{_player}'s targeted block is any trapdoor
		{_player}'s targeted block is any fence gate
		{_player}'s targeted block is any sign
		{_player}'s targeted entity is an item frame
		{_player}'s targeted entity is an armor stand
		{_player}'s targeted block is a lever
		{_player}'s targeted block is any button
		{_player}'s targeted block is a redstone repeater
		{_player}'s targeted block is a comparator
	then:
		return false

	return true

function rollDie(sides: number) :: number:
	set {_value} to a random integer between 1 and {_sides}
	scriptDebugBroadcastType("dice", "rollDie(%{_sides}%) = %{_value}%")
	return {_value}

function rollDice(dice: number, sides: number) :: number:
	set {_total} to 0
	loop {_dice} times:
		add rollDie({_sides}) to {_total}
	scriptDebugBroadcastType("dice", "rollDice(%{_dice}%, %{_sides}%) = %{_total}%")
	return {_total}

command /dice <number> <number>:
	trigger:
		set {_value} to rollDice(arg 1, arg 2)
		send "&9 %arg 1%d%arg 2% -> %{_value}%" to command executor

function addResearch(player: player, name: string, level: number=1):
	set {rpgSkript::%{_player}%::research::%{_name}%} to {_level}
	send "&eYou have earned research ""%{_name}%"" Level %{_level}%" to {_player}

function deleteResearch(player: player, name: string):
	delete {rpgSkript::%{_player}%::research::%{_name}%}
	send "&cYou have lost research ""%{_name}%""" to {_player}

function hasResearch(player: player, name: string) :: boolean:
	if featureEnabled("g_%{_name}%_research") is false:
		return false
	if {rpgSkript::%{_player}%::research::%{_name}%} is set:
		return true
	return false

function getResearchLevel(player: player, name: string) :: number:
	if {rpgSkript::%{_player}%::research::%{_name}%} is not set:
		return 0
	return {rpgSkript::%{_player}%::research::%{_name}%}

function explodeRadius(block: block, range: number):
	loop all blocks in radius {_range} around {_block}:
		loop-block is not bedrock:
			break loop-block naturally using diamond pickaxe

local function drawLine(loc1: location, loc2: location):
	set {_v} to vector from {_loc1} to {_loc2}
	set vector length of {_v} to 0.25
	loop floor((distance between {_loc1} and {_loc2}) / 0.25) times:
		draw 1 flame at {_loc1} with extra 0
		set {_loc1} to {_loc1} ~ {_v}

function playSoundToPlayers(loc: location, sound: string, range: number, pitch: number=1):
	loop players in radius {_range} of {_loc}:
		play sound "%{_sound}%" with pitch {_pitch} for loop-player

command /haslore <text>:
	executable by: players
	trigger:
		send "hasImbue: %hasImbue(command executor, arg 1)%"

command /armorclass:
	executable by: players
	trigger:
		send "Nothing: %isWearingNothing(command executor)%"
		send "Light or less: %isWearingLightOrLess(command executor)%"
		send "Medium or less: %isWearingMediumOrLess(command executor)%"
		send "Heavy or less: %isWearingHeavyOrLess(command executor)%"

function arcaneTide():
	{rpgSkript::arcaneTide} is not set:
		set {_x} to a random number between 1 and 1000
		{_x} < 7:
			set {rpgSkript::arcaneTide} to now
			arcaneSense("You feel the surrounding energy of Magic become more intense!")
	else:
		if difference between now and {rpgSkript::arcaneTide} is greater than 2 minutes:
			set {_x} to a random number between 1 and 1000
			{_x} < 20:
				delete {rpgSkript::arcaneTide}
				arcaneSense("The energy in the air settles...")

function countEntities(mobs: entities) :: number:
	set {_x} to 0
	loop {_mobs::*}:
		set {_x} to {_x} + 1
	return {_x}

on heal:
	entity is not alive:
		cancel the event

function fullHeal(entity: entity):
	heal({_entity}, max health of {_entity})

function heal(entity: entity, amount: number) :: boolean:
	if {_entity} is not alive:
		return false
	{_entity} is a player:
		hasClass({_entity}, "cleric") is true:
			set {_amount} to {_amount} * 2
	heal {_entity} by {_amount}
	scriptDebugBroadcastType("heal", "%{_entity}% heals for %{_amount}%")
	return true

on join:
	setMaxHealth(the player)
	set the player's health to the player's health

function createWorldEffect(loc: location, name: text, duration: time span, creator: entity={_none}):
	set {_id} to a random UUID
	set {-rpgSkript::worldeffects::%{_id}%} to 0
	set {-rpgSkript::worldeffects::%{_id}%::location} to {_loc}
	set {-rpgSkript::worldeffects::%{_id}%::name} to {_name}
	set {-rpgSkript::worldeffects::%{_id}%::duration} to {_duration}
	set {-rpgSkript::worldeffects::%{_id}%::creator} to {_creator}
	set {-rpgSkript::worldeffects::%{_id}%::started} to now
	scriptDebugBroadcastType("world_effect", "Created world effect %{_name}% at %{_loc}% for %{_duration}%, created by %{_creator}%")

function drawWorldEffect(index: text):
	set {_loc} to {-rpgSkript::worldeffects::%{_index}%::location}
	set {_name} to {-rpgSkript::worldeffects::%{_index}%::name}

	{_name} is "electric_smoke":
		loop blocks in radius 12 around {_loc}:
			chance of 5%:
				show cloud at loop-block

function handleWorldEffect(index: text):
	set {_loc} to {-rpgSkript::worldeffects::%{_index}%::location}
	set {_name} to {-rpgSkript::worldeffects::%{_index}%::name}
	set {_started} to {-rpgSkript::worldeffects::%{_index}%::started}
	set {_duration} to {-rpgSkript::worldeffects::%{_index}%::duration}
	set {_creator} to {-rpgSkript::worldeffects::%{_index}%::creator}

	set {_diff} to difference between now and {_started}
	{_diff} is greater than {_duration}:
		delete {-rpgSkript::worldeffects::%{_index}%::*}
		delete {-rpgSkript::worldeffects::%{_index}%}
		scriptDebugBroadcastType("world_effect", "Deleted world effect %{_name}% at %{_loc}%")
		stop

	{_name} is "electric_smoke":
		loop entities in radius 13 around {_loc}:
			chance of 60%:
				damage loop-entity by 1

every 5 ticks:
	loop {-rpgSkript::worldeffects::*}:
		drawWorldEffect(loop-index)

every 10 ticks:
	loop {-rpgSkript::worldeffects::*}:
		handleWorldEffect(loop-index)

function isImmuneToEffect(entity: entity, name: string) :: boolean:

	{_name} is "disease":
		{_entity} is a player:
			hasClass({_entity}, "paladin") is true:
				return true
			hasImbue({_entity}, "iron will") is true:
				return true
		{_entity} is a zombie or skeleton:
			return true

	{_name} is "hallowed":
		{_entity} is a player:
			hasClass({_entity}, "paladin") is true:
				return true

	return false

function generateIndex(entity: entity) :: text:
	{_entity} is a player:
		set {_index} to name of {_entity}
	else:
		set {_index} to "entity-%uuid of {_entity}%"
	scriptDebugBroadcastType("generateIndex", "%{_index}%")
	return {_index}

function removeAllEffects(entity: entity):
	set {_index} to generateIndex({_entity})
	loop {-rpgSkript::effects::%{_index}%::*}:
		removeEffect({_entity}, loop-index)

function removeEffect(entity: entity, name: string):
	scriptDebugBroadcastType("effect", "Removing Effect %{_name}% from %{_entity}%")
	set {_index} to generateIndex({_entity})
	delete {-rpgSkript::effects::%{_index}%::%{_name}%}
	delete {-rpgSkript::effects::%{_index}%::%{_name}%::*}

function applyEffect(entity: entity, name: string, duration: timespan):
	scriptDebugBroadcastType("effect", "Applying Effect %{_name}% to %{_entity}% for %{_duration}%")
	set {_index} to generateIndex({_entity})
	set {-rpgSkript::effects::%{_index}%::%{_name}%} to 0
	set {-rpgSkript::effects::%{_index}%::%{_name}%::duration} to {_duration}
	set {-rpgSkript::effects::%{_index}%::%{_name}%::applied} to now

function hasEffect(entity: entity, name: string) :: boolean:
	if featureEnabled("effects") is false:
		return false
	if featureEnabled("g_%{_name}%_effect") is false:
		return false

	isImmuneToEffect({_entity}, {_name}) is true:
		return false

	{_entity} is a player:
		hasImbue({_entity}, "%{_name}% effect") is true:
			return true

	set {_index} to generateIndex({_entity})
	{-rpgSkript::effects::%{_index}%::%{_name}%} is not set:
		return false

	set {_diff} to difference between now and {-rpgSkript::effects::%{_index}%::%{_name}%::applied}
	{_diff} is greater than {-rpgSkript::effects::%{_index}%::%{_name}%::duration}:
		return false

	return true

function drawEffects(entity: entity):

	# This shouldDraw is an optimization.
	# Particle effects only really matter to players, who can only seem them from so far away.
	# This will ensure that the script does not even attempt to draw particles around an entity
	# that no player will even see. This will allow the drawEffects to run faster.
	
	set {_shouldDraw} to false
	loop players in radius {@drawRadius} around {_entity}:
		set {_shouldDraw} to true
		exit 1 loop

	{_shouldDraw} is false:
		stop

	hasEffect({_entity}, "test") is true:
		show rollDice(2, 3) (flame with offset of 0.2, 0.0, 0.2) at (location of {_entity} ~ vector 0, 0.1, 0)
	hasEffect({_entity}, "test2") is true:
		loop 5 times:
			set {_x} to a random number between -0.5 and 0.5
			set {_y} to a random number between 0 and 2
			set {_z} to a random number between -0.5 and 0.5
			show dragon breath at (location of {_entity} ~ vector {_x}, {_y}, {_z})
	hasEffect({_entity}, "test3") is true:
		loop 5 times:
			set {_x} to a random number between -0.5 and 0.5
			set {_y} to 2.5
			set {_z} to a random number between -0.5 and 0.5
			show water drip at (location of {_entity} ~ vector {_x}, {_y}, {_z})
	hasEffect({_entity}, "test4") is true:
		show rollDice(3, 3) (electric spark with offset of 0.3, 0.5, 0.3) at (location of {_entity} ~ vector 0, 1, 0)
	hasEffect({_entity}, "hallowed") is true:
		show rollDice(3, 3) (electric spark with offset of 0.3, 0.5, 0.3) at (location of {_entity} ~ vector 0, 1, 0)
	hasEffect({_entity}, "shocking") is true:
		show rollDice(3, 3) (end rod with offset of 0.3, 0.5, 0.3) at (location of {_entity} ~ vector 0, 1, 0)
	hasEffect({_entity}, "bleeding") is true:
		show rollDice(3, 3) (red dust with offset of 0.3, 0.5, 0.3) at (location of {_entity} ~ vector 0, 1, 0)
	hasEffect({_entity}, "disease") is true:
		show rollDice(3, 3) (falling spore blossom with offset of 0.3, 0.5, 0.3) at (location of {_entity} ~ vector 0, 1, 0)
	hasEffect({_entity}, "mana_leak") is true:
		loop 5 times:
			set {_x} to a random number between -0.5 and 0.5
			set {_y} to 1.0
			set {_z} to a random number between -0.5 and 0.5
			show blue dust at (location of {_entity} ~ vector {_x}, {_y}, {_z})

command /rpgeffect <player> <text> <timespan>:
	trigger:
		command executor has permission "rpg.control"
		applyEffect(arg 1, arg 2, arg 3)

every 1 seconds:
	loop all players:
		clear loop-player's scoreboard
		set title of loop-player's scoreboard to "&eInformation"
		set line 15 of loop-player's scoreboard to "&a"
		set line 14 of loop-player's scoreboard to "&3&l   RPG"
		set line 13 of loop-player's scoreboard to "&a"
		set line 12 of loop-player's scoreboard to "&3 Mana: %{rpgSkript::mana::%loop-player%}% / %{rpgSkript::maxMana::%loop-player%}%"

		calculateMaxMinions(loop-player) > 0:
			set line 10 of loop-player's scoreboard to "&d Minions: %getMinionCount(loop-player)% / %calculateMaxMinions(loop-player)%"

		hasClass(loop-player, "druid") is true:
			set line 8 of loop-player's scoreboard to "&6 Wildshape: %{rpgSkript::%loop-player%::wildshape}% / %{rpgSkript::%loop-player%::maxWildshape}%"
			if {rpgSkript::%loop-player%::batshape} is true:
				set line 7 of loop-player's scoreboard to "&a Current Form: Bat"
			if {rpgSkript::%loop-player%::wolfshape} is true:
				set line 7 of loop-player's scoreboard to "&a Current Form: wolf"
			if {rpgSkript::%loop-player%::spidershape} is true:
				set line 7 of loop-player's scoreboard to "&a Current Form: Spider"
			if {rpgSkript::%loop-player%::horseshape} is true:
				set line 7 of loop-player's scoreboard to "&a Current Form: Horse"
			if {rpgSkript::%loop-player%::bearshape} is true:
				set line 7 of loop-player's scoreboard to "&a Current Form: Bear"
			if {rpgSkript::%loop-player%::humanshape} is true:
				set line 7 of loop-player's scoreboard to "&a Current Form: Human"
		hasClass(loop-player, "barbarian") is true:
			set line 11 of loop-player's scoreboard to "&4 Rage: %{rpgSkript::%loop-player%::rage}% / %{rpgSkript::%loop-player%::maxRage}%"

		hasClass(loop-player, "rogue") is true:
			set line 4 of loop-player's scoreboard to "Monsters: %countEntities(monsters within 20 meters of loop-player)%"
			set line 3 of loop-player's scoreboard to "Animals: %countEntities(animals within 30 meters of loop-player)%"
			set line 2 of loop-player's scoreboard to "Players: %countEntities(players within 50 meters of loop-player)%"
			set line 1 of loop-player's scoreboard to "Items on Ground: %countEntities(dropped items within 30 meters of loop-player)%"

every 4 ticks:
	set {_start} to now

	loop all players:
		drawEffects(loop-player)
		loop all mobs in radius {@drawRadius} of loop-player:
			loop-mob is alive
			{_drawn::%uuid of loop-entity-2%} is not set:
				drawEffects(loop-entity-2)
				set {_drawn::%uuid of loop-entity-2%} to 0

	set {_end} to now
	set {_seconds} to difference between {_end} and {_start}
	scriptDebugConsoleMessageType("effects_loop_time", "Took %{_seconds}%")

every 1 seconds:
	loop all entities:
		loop-entity is alive
		set {_effectDamage} to 0
		hasEffect(loop-entity, "hallowed") is true:
			if isMonster(loop-entity) is true:
				set {_effectDamage} to {_effectDamage} + 1
			else:
				set {_effectDamage} to {_effectDamage} + 0.5
		hasEffect(loop-entity, "bleeding") is true:
			if hasClass(loop-entity, "warrior") is false:
				set {_effectDamage} to {_effectDamage} + 0.05 * maximum health of loop-entity 
		hasEffect(loop-entity, "mana_leak") is true:
			loop-entity is a player
			set {_loss} to ({rpgSkript::maxMana::%loop-entity%} / 40) / 2
			subMana(loop-entity, {_loss}, false)
		hasEffect(loop-entity, "shocking") is true:
			apply slowness 255 without particles to the loop-entity for 2 seconds replacing the existing effect
			loop all entities in radius 5 around loop-entity:
				loop-entity-2 is not loop-entity-1
				hasEffect(loop-entity-2, "shocking") is false
				set {_effectDamage} to {_effectDamage} + 1
				applyEffect(loop-entity-2, "shocking", 0.1 seconds)
				set {_vec} to vector between loop-entity-1 and loop-entity-2
				set y component of {_vec} to 0
				set {_vec} to normalized {_vec}
				push loop-entity-2 {_vec} with force 1.4
				push loop-entity-2 upwards with force 0.8
				chance of 30%:
					hasEffect(loop-entity-2, "shocking") is false:
						applyEffect(loop-entity-2, "shocking", 2 seconds)
		hasEffect(loop-entity, "disease") is true:
			chance of 10%:
				set {_effectDamage} to {_effectDamage} + 1.5
			loop all entities in radius 5 around loop-entity:
				loop-entity-2 is not loop-entity-1
				loop-entity-2 is alive
				chance of 30%:
					applyEffect(loop-entity-2, "disease", 30 seconds)

		if {_effectDamage} is not 0:
			set {_reduction} to 1 - (0.15 * countImbue(loop-entity, "iron will") )
			damage loop-entity by {_effectDamage} * {_reduction}

every 2 seconds:

	arcaneTide()

	loop all players:
		setMaxHealth(loop-player)

		setupMana(loop-player)
		regenMana(loop-player)

		setupRage(loop-player)
		setupWildshape(loop-player)

		cullMinions(loop-player)
		
		hasClass(loop-player, "wizard") is true:
			getPlayerLevel(loop-player) >= 80
			if hasResearch(loop-player, "power") is true:
				add 3 experience to loop-player
		hasClass(loop-player, "warrior") is true:
			heal(loop-player, 1)
			loop-player's knockback resistance attribute is not 0.7:
				set loop-player's knockback resistance attribute to 0.7
			apply haste 2 without particles to the loop-player for 30 seconds replacing the existing effect
			apply strength 1 without particles to the loop-player for 30 seconds replacing the existing effect
		hasClass(loop-player, "paladin") is true:
			heal(loop-player, 2)
			loop entities in radius 50 of loop-player:
				isMonster(loop-entity-2) is true
				loop-entity-2 is not loop-player
				apply slowness 1 to the loop-entity-2 for 20 seconds replacing the existing effect
				apply weakness 1 to the loop-entity-2 for 20 seconds replacing the existing effect
				chance of 30%:
					applyEffect(loop-entity-2, "hallowed", 8 seconds)
		hasClass(loop-player, "herobrine") is true:
			heal(loop-player, 2)
			loop-player's knockback resistance attribute is not 0.9:
				set loop-player's knockback resistance attribute to 0.9
			apply haste 6 without particles to the loop-player for 30 seconds replacing the existing effect
			apply strength 4 without particles to the loop-player for 30 seconds replacing the existing effect
		hasClass(loop-player, "barbarian") is true:
			canUseBarbarianAbilities(loop-player) is true:
				regenRage(loop-player)

		hasClass(loop-player, "druid") is true:
			time in world of loop-player is between 23:00 and 1:00:
				regenWildshape(loop-player)
			block at loop-player is water:
				apply dolphin's grace to loop-player for 5 seconds replacing the existing effect
				apply water breathing to loop-player for 5 seconds replacing the existing effect

			if {rpgSkript::%loop-player%::batshape} is not set:
				set {rpgSkript::%loop-player%::batshape} to false
			if {rpgSkript::%loop-player%::bearshape} is not set:
				set {rpgSkript::%loop-player%::bearshape} to false
			if {rpgSkript::%loop-player%::wolfshape} is not set:
				set {rpgSkript::%loop-player%::wolfshape} to false
			if {rpgSkript::%loop-player%::horseshape} is not set:
				set {rpgSkript::%loop-player%::horseshape} to false
			if {rpgSkript::%loop-player%::spidershape} is not set:
				set {rpgSkript::%loop-player%::spidershape} to false
			if {rpgSkript::%loop-player%::humanshape} is not set:
				set {rpgSkript::%loop-player%::humanshape} to true

			if canUseShapeshiftAbilities(loop-player) is true:
				if {rpgSkript::%loop-player%::batshape} is true:
					if light level at loop-player is greater than 10:
						apply blindness 2 without particles to the loop-player for 10 seconds replacing the existing effect
					else:
						apply night vision 2 without particles to the loop-player for 10 seconds replacing the existing effect
				if {rpgSkript::%loop-player%::wolfshape} is true:
					apply night vision 2 without particles to the loop-player for 10 seconds replacing the existing effect
					apply swiftness 1 without particles to the loop-player for 3 seconds replacing the existing effect
				if {rpgSkript::%loop-player%::horseshape} is true:
					apply swiftness 2 without particles to the loop-player for 3 seconds replacing the existing effect
					apply jump boost 2 without particles to the loop-player for 3 seconds replacing the existing effect
				if {rpgSkript::%loop-player%::bearshape} is true:
					apply strength 2 without particles to the loop-player for 3 seconds replacing the existing effect
			else:
				set {rpgSkript::%loop-player%::bearshape} to false
				set {rpgSkript::%loop-player%::horseshape} to false
				set {rpgSkript::%loop-player%::spidershape} to false
				set {rpgSkript::%loop-player%::wolfshape} to false
				set {rpgSkript::%loop-player%::batshape} to false
				set {rpgSkript::%loop-player%::humanshape} to true

			canUseDruidAbilities(loop-player) is true:	
				loop all blocks in radius 5 around loop-player:
					if loop-block is a flower:
						apply regeneration 1 without particles to the loop-player for 3 seconds replacing the existing effect

		hasClass(loop-player, "endwarden") is true:
			if {rpgSkript::%loop-player%::eteleport} is not set:
				set {rpgSkript::%loop-player%::eteleport} to true

		if canFly(loop-player) is true:
			enable flight for loop-player
		else:
			disable flight for loop-player

		hasImbue(loop-player, "golem") is true:
			apply strength 2 without particles to the loop-player for 5 seconds replacing the existing effect
			apply slowness 1 without particles to the loop-player for 5 seconds replacing the existing effect
		hasImbue(loop-player, "photosynthesis") is true:
			sun light level at loop-player is greater than 13:
				time in world of loop-player is not between 19:00 and 5:00:
					set {_add} to 0.25 * countImbue(loop-player, "photosynthesis")
					heal(loop-player, {_add})

function getTag(item: item, name: text) :: text:
	set {_value} to tag {_name} of nbt of {_item}
	scriptDebugBroadcastType("tag", "%{_item}% tag %{_name}%: %{_value}%")
	return {_value}

on right click with glass bottle:
	hasLore(event-player's held item, "holding") is true
	cancel the event
	set {_id} to getTag(event-player's held item, "holdingId")
	scriptDebugBroadcastType("holding", "ID: %{_id}%")
	if {_id} is not set:
		scriptDebugBroadcastType("holding", "ID not set, creating new holding inventory")
		set {_id} to a random UUID
		{rpgSkript::holding::%{_id}%} is not set:
			scriptDebugBroadcastType("holding", "New ID: %{_id}%")
			set {rpgSkript::holding::%{_id}%} to 1
			set tag "holdingId" of nbt of event-player's held item to {_id}
		else:
			stop
	set {_inv} to chest inventory with 6 rows named "&eBottle of Holding"
	loop 6*9 times:
		set slot (loop-value)-1 of {_inv} to {rpgSkript::holding::%{_id}%::%loop-value%}
	open {_inv} to player

on inventory close:
	if event-inventory's name is "&eBottle of Holding":
		set {_id} to getTag(player's held item, "holdingId")
		{_id} is not set:
			scriptDebugBroadcastType("holding", "ID not set, cannot save inventory")
			stop
		loop 6*9 times:
			set {rpgSkript::holding::%{_id}%::%loop-value%} to slot (loop-value)-1 of event-inventory

on death:
	removeAllEffects(victim)
	
	isMonster(victim) is true:
		chance of 4%:
			set {_item} to generateRandomLoot()
			hasAnyImbue({_item}) is true:
				scriptDebugBroadcastType("loot", "Added %{_item}% to mob loot")
				# add {_item} to the drops

on experience change:
	hasImbue(event-player, "enlighten") is true:
		while true is true:
			wait 10 ticks
			chance of 60%:
				add 1 experience to event-player
			else:
				exit 1 loop

on damage:
	damage cause is fall:
		loop all entities in radius 15 around victim:
			hasClass( loop-entity, "endwarden") is true:
				canUseEndwardenAbilities( loop-entity ) is true:
					hasClass( victim, "endwarden") is false:
						set the damage to the damage * 1.3
						exit 1 loop

	isMinion(attacker) is true:
		isMinion(victim) is true:
			hasSameSummoner(attacker, victim) is true:
				cancel the event
				stop
		else:
			isMonster(victim) is true:
				the victim is not a creeper:
					set the target of the victim to the attacker
			getSummoner(uuid of the attacker) is the victim:
				cancel the event
				stop
		attacker is a spider:
			if victim has potion effect poison:
				set the damage to the damage * 1.2
			else:
				chance of 20%:
					apply poison 1 without particles to the victim for 5 seconds replacing the existing effect

		hasClass(getSummoner(uuid of attacker), "necromancer") is true:
			add 1 experience to getSummoner(uuid of attacker)

	attacker is a player:

		hasClass(attacker, "druid") is true:
			if {rpgSkript::%attacker%::humanshape} is true:
				attacker's held item is a stick:
					set the damage to 2.0
			else:
				if attacker's held item is not air:
					cancel the event
					stop
				if {rpgSkript::%attacker%::spidershape} is true:
					if victim has potion effect poison:
						set the damage to 1.5
					else:
						chance of 30%:
							apply poison 1 without particles to the victim for 5 seconds replacing the existing effect
				else if {rpgSkript::%attacker%::wolfshape} is true:
					set the damage to 1.5
					applyEffect(victim, "bleeding", 8 seconds)
				else if {rpgSkript::%attacker%::bearshape} is true:
					set the damage to 3
				else if {rpgSkript::%attacker%::batshape} is true:
					set the damage to 0

		hasClass(attacker, "rogue") is true:
			canUseRogueAbilities(attacker) is true
			set the damage to the damage * 2.0
		hasClass(attacker, "herobrine") is true:
			set the damage to the damage * 3.0
		hasClass(attacker, "paladin") is true:
			isMonster(victim) is true:
				set the damage to the damage * 1.4
				applyEffect(victim, "hallowed", 8 seconds)
		hasClass(attacker, "barbarian") is true:
			if event-projectile is set:
				set the damage to the damage * 0.65
			else if canUseBarbarianAbilities( attacker ) is true:
				set the damage to the damage * 1.5
				attacker is holding air:
					set {_vec} to vector between attacker and victim
					set y component of {_vec} to 0
					set {_vec} to normalized {_vec}
					push victim {_vec} with force 1.2
					push victim upwards with force 0.8

		if hasLore(attacker's held item, "vampiric") is true:
			set {_heal} to 0.5 * countImbue(attacker, "vampiric")
			heal(attacker, {_heal})
		if hasLore(attacker's held item, "hallowed") is true:
			applyEffect(victim, "hallowed", 10 seconds)
		if hasLore(attacker's held item, "shocking") is true:
			applyEffect(victim, "shocking", 2 seconds)
		if hasLore(attacker's held item, "bleeding") is true:
			applyEffect(victim, "bleeding", 10 seconds)
		if hasLore(attacker's held item, "mana_leak") is true:
			applyEffect(victim, "mana_leak", 10 seconds)
		if hasLore(attacker's held item, "disease") is true:
			applyEffect(victim, "disease", 30 seconds)
		if hasLore(attacker's held item, "firststrike") is true:
			health of victim is equal to the maximum health of victim:
				set the damage to the damage * 1.5
		if hasLore(attacker's held item, "siphon") is true:
			if victim is a player:
				subMana(victim, 25, false)
			addMana(attacker, 15)

	victim is a player:
		setMaxHealth(the victim)

		hasClass(victim, "herobrine") is true:
			set the damage to the damage * 0.3
			damage cause is fall:
				cancel the event
			damage cause is burn:
				cancel the event
			damage cause is lava:
				cancel the event
			damage cause is hot floor:
				cancel the event
			damage cause is drowning:
				cancel the event
			damage cause is freeze:
				cancel the event
		hasClass(victim, "warrior") is true:
			set the damage to the damage * 0.65
		hasClass(victim, "rogue") is true:
			canUseRogueAbilities(victim) is true
			damage cause is fall:
				set the damage to the damage * 0.3
			chance of 45%:
				set the damage to 0
				play sound "entity.player.attack.nodamage" at victim
				send action bar "&2~ ~ DODGE ~ ~" to victim
		hasClass(victim, "paladin") is true:
			isMonster(attacker) is true:
				set the damage to the damage * 0.6
			damage cause is poison:
				cancel the event
			damage cause is wither potion effect:
				cancel the event
		hasClass(victim, "barbarian") is true:
			event-projectile is set:
				set the damage to the damage * 1.3
			canUseBarbarianAbilities(victim) is true:
				if chance of 5%:
					rageTrigger(victim)
		hasClass(victim, "endwarden") is true:
			canUseEndwardenAbilities(victim) is true:
				damage cause is fall:
					health of victim is less than damage:
						set the damage to maximum health of victim / 2
						endTeleport( victim )
						stop
				health of victim is less than damage:
					chance of 30:
						set the damage to the damage / 2 
						endTeleport(victim)
						stop
		hasClass(victim, "druid") is true:
			canUseDruidAbilities(victim) is true:
				if {rpgSkript::%victim%::spidershape} is true:
					damage cause is poison:
						cancel the event
						stop
				else if {rpgSkript::%victim%::batshape} is true:
					set the damage to the damage * 1.25
					damage cause is fall:
						set the damage to 0

		hasImbue(victim, "mana shield") is true:
			subMana(victim, the damage * 7.0, false) is true
			set {_reduction} to 1 - (0.15 * countImbue(victim, "mana shield") )
			if {_reduction} is less than 0.5:
				set {_reduction} to 0.5
			set the damage to the damage * {_reduction}

		hasImbue(victim, "flame shield") is true:
			set {_loc} to the victim's location
			set {_loc} to the location 1 meter above {_loc}
			show mob spawner flames at {_loc}
			event-projectile is set:
				delete event-projectile
				cancel the event
				stop
			if damage cause is burn:
				set the damage to the damage * 0.75
			else:
				set the damage to the damage * 0.95
			ignite the attacker for 2 seconds

		hasImbue(victim, "frost shield") is true:
			set {_loc} to the victim's location
			set {_loc} to the location 1 meter above {_loc}
			show splash at {_loc}
			event-projectile is not set:
				if damage cause is freeze:
					set the damage to the damage * 0.75
				else:
					set the damage to the damage * 0.95

		hasImbue(victim, "iron will") is true:
			if at least one of:
				damage cause is burn
				damage cause is freeze
				damage cause is poison
				damage cause is wither potion effect
			then:
				set {_reduction} to 1 - (0.15 * countImbue(victim, "iron will") )
				set the damage to the damage * {_reduction}


on target:
	isMinion(event-entity) is true:
		target is a player:
			cancel the event
			stop
		getSummoner(uuid of event-entity) is target:
			cancel the event
			stop
		isMinion(target) is true:
			hasSameSummoner(event-entity, target) is true:
				cancel the event
				stop

	target is a player
	hasClass(target, "herobrine") is true:
		cancel the event
		stop
	hasClass(target, "rogue") is true:
		canUseRogueAbilities(target) is true
		distance between event-entity and target is greater than 10:
			cancel the event
			stop
		chance of 80%:
			cancel the event
			stop
	hasClass(target, "paladin") is true:
		isMonster(event-entity) is true:
			applyEffect(event-entity, "hallowed", 8 seconds)
	hasClass(target, "druid") is true:
		if {rpgSkript::%target%::wolfshape} is true:
			chance of 60%:
				cancel the event
				stop
		else if {rpgSkript::%target%::spidershape} is true:
			chance of 40%:
				cancel the event
				stop

on item damage:
	hasLore(event-item, "unbreakable") is true:
		cancel the event
		stop
	hasClass(player, "herobrine") is true:
		cancel the event
		stop
	hasClass(player, "paladin") is true:
		subMana(player, 2, false) is true:
			cancel the event
			stop
	hasClass(player, "warrior") is true:
		chance of 45%:
			cancel the event
			stop
	hasClass(player, "rogue") is true:
		chance of 25%:
			cancel the event
			stop

function generateLootHelmet() :: item:
	set {_item} to a leather helmet
	chance of 50%:
		set {_item} to a gold helmet
	chance of 30%:
		set {_item} to a iron helmet
	chance of 10%:
		set {_item} to a diamond helmet
	chance of 5%:
		set {_item} to a netherite helmet

	chance of 4%:
		set {_item} to addImbue({_item}, "&7Necromancer Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&eCleric Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&bPaladin Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&2Rogue Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&cWarrior Class")
	
	return {_item}

function generateLootChestplate() :: item:
	set {_item} to a leather chestplate
	chance of 50%:
		set {_item} to a gold chestplate
	chance of 30%:
		set {_item} to a iron chestplate
	chance of 10%:
		set {_item} to a diamond chestplate
	chance of 5%:
		set {_item} to a netherite chestplate

	chance of 4%:
		set {_item} to addImbue({_item}, "&7Necromancer Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&eCleric Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&bPaladin Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&2Rogue Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&cWarrior Class")

	return {_item}

function generateLootLeggings() :: item:
	set {_item} to a leather leggings
	chance of 50%:
		set {_item} to a gold leggings
	chance of 30%:
		set {_item} to a iron leggings
	chance of 10%:
		set {_item} to a diamond leggings
	chance of 5%:
		set {_item} to a netherite leggings

	chance of 4%:
		set {_item} to addImbue({_item}, "&7Necromancer Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&eCleric Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&bPaladin Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&2Rogue Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&cWarrior Class")

	return {_item}

function generateLootBoots() :: item:
	set {_item} to a leather boots
	chance of 50%:
		set {_item} to a gold boots
	chance of 30%:
		set {_item} to a iron boots
	chance of 10%:
		set {_item} to a diamond boots
	chance of 5%:
		set {_item} to a netherite boots

	chance of 4%:
		set {_item} to addImbue({_item}, "&7Necromancer Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&eCleric Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&bPaladin Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&2Rogue Class")
	chance of 4%:
		set {_item} to addImbue({_item}, "&cWarrior Class")

	return {_item}

function generateRandomLoot() :: item:
	scriptDebugBroadcastType("loot", "Generating random loot item")
	
	chance of 1%:
		set {_item} to generateLootHelmet()
	chance of 1%:
		set {_item} to generateLootChestplate()
	chance of 1%:
		set {_item} to generateLootLeggings()
	chance of 1%:
		set {_item} to generateLootBoots()

	return {_item}

on loot generate:
	scriptDebugBroadcastType("loot", "Loot table generated")

	set {_item} to generateRandomLoot()

	hasAnyImbue({_item}) is true:
		chance of 1%:
			add {_item} to the loot
			scriptDebugBroadcastType("loot", "Added %{_item}% to the loot")

command /rpgloot <text>:
	executable by: players
	trigger:
		player has permission "rpg.control"
		arg 1 is "helmet":
			giveItem(player, generateLootHelmet())
		arg 1 is "chestplate":
			giveItem(player, generateLootChestplate())
		arg 1 is "leggings":
			giveItem(player, generateLootLeggings())
		arg 1 is "boots":
			giveItem(player, generateLootBoots())

command /rpgrandloot:
	executable by: players
	trigger:
		player has permission "rpg.control"
		set {_x} to 0
		while hasAnyImbue({_item}) is false:
			set {_item} to generateRandomLoot()
			set {_x} to {_x} + 1

		give {_item} to player
		send "&cTook %{_x}% rolls" to player

on chunk generate:
	scriptDebugBroadcastType("chunk", "Chunk Generated")

on chunk load:
	scriptDebugBroadcastType("chunk", "Chunk Loaded")

on chunk unload:
	scriptDebugBroadcastType("chunk", "Chunk Unloaded")

function generateTime(seconds: number) :: time span:
	return "%{_seconds}% seconds" parsed as time span

on sprint toggle:
	if hasClass(player, "herobrine") is true:
		player is not sprinting:
			apply swiftness 4 without particles to the player for 30 seconds replacing the existing effect
			apply jump boost 4 without particles to the player for 30 seconds replacing the existing effect
		player is sprinting:
			remove swiftness from the player
			remove jump boost from the player
	else if hasClass(player, "rogue") is true:
		player is not sprinting:
			canUseRogueAbilities(player) is true
			apply swiftness 2 without particles to the player for 30 seconds replacing the existing effect
			apply jump boost 2 without particles to the player for 30 seconds replacing the existing effect
		player is sprinting:
			remove swiftness from the player
			remove jump boost from the player

on sneak toggle:
	if hasClass(player, "herobrine") is true:
		player is not sneaking:
			apply invisibility without particles to the player for 30 seconds replacing the existing effect
		player is sneaking:
			remove invisibility from the player
	else if hasClass(player, "rogue") is true:
		player is not sneaking:
			canUseRogueAbilities(player) is true
			light level at the player is less than 11
			apply invisibility without particles to the player for 30 seconds replacing the existing effect
			loop all monsters in radius 40 of player:
				target of loop-monster is player:
					reset target of loop-monster
		player is sneaking:
			remove invisibility from the player

on jump:
	entity is a player
	if hasClass(player, "herobrine") is true:
		player is sprinting
		push the player horizontally forward with force 1.5	
	else if hasClass(player, "rogue") is true:
		player is sprinting
		if canUseRogueAbilities(player) is true:
			push the player horizontally forward with force 0.7
	else if hasClass(player, "druid") is true:
		player is sprinting
		if {rpgSkript::%player%::horseshape} is true:
			push the player horizontally forward with force 0.7

on hunger meter change:
	if hasClass(player, "herobrine") is true:
		if {rpgSkript::%player%::filling_hunger} is true:
			delete {rpgSkript::%player%::filling_hunger}
			stop trigger
		else if the player's hunger meter is less than 10:
			set {rpgSkript::%player%::filling_hunger} to true
			set the player's hunger meter to 10
	else if hasClass(player, "rogue") is true:
		if {rpgSkript::%player%::eating} is true:
			set {rpgSkript::%player%::eating} to false
			stop
		else:
			chance of 80%:
				cancel the event

on consume:
	set {rpgSkript::%player%::eating} to true
	if event-item is a water bottle:
		hasClass(player, "endwarden") is true:
			send "&2~ ~ Do we are have stupid? ~ ~" to player
			wait 5 seconds
			kill player
	if event-item is a spider eye:
		hasClass(player, "druid") is true:
			cancel the event

on enderman pickup: 
	isMinion(event-entity) is true: 
		cancel the event

on spawn:
	isMinion(event-entity) is true:
		set {_caster} to getSummoner(uuid of event-entity)
		hasClass({_caster}, "endwarden") is true:
			event-entity is an enderman:
				set maximum health of event-entity to 10
				fullHeal(event-entity)
		hasClass({_caster}, "druid") is true:
			event-entity is a wolf:
				set maximum health of event-entity to 10
				set movement speed attribute of event-entity to 1.4 * movement speed attribute of event-entity
				set armor attribute of event-entity to 3
			event-entity is a spider:
				set maximum health of event-entity to 12
				set movement speed attribute of event-entity to 1.2 * movement speed attribute of event-entity
				set armor attribute of event-entity to 0
			event-entity is a polar bear:
				set maximum health of event-entity to 16
				set movement speed attribute of event-entity to 1.2 * movement speed attribute of event-entity
				set armor attribute of event-entity to 5
			fullHeal(event-entity)



# Warrior



command /warriorresearch:
	executable by: players
	trigger:
		hasClass(player, "warrior") is false:
			send "&dYou are not a warrior!"
			exit
		set {_menu} to a new chest inventory with 6 rows named "&cWarrior Research"
		
		populateWarriorResearchMenu(player, {_menu})
		
		open {_menu} to player

function populateWarriorResearchMenu(player: player, menu: inventory):
	set {_item} to red wool named "&7Master Smith"
	if hasResearch({_player}, "master_smith") is true:
		set {_item} to lime wool named "&eMaster Smith"
	set line 1 of {_item}'s lore to "&6Tools and Armor that you craft are enchanted"
	set slot 30 of {_menu} to {_item}

	set {_item} to red wool named "&7Durable"
	if hasResearch({_player}, "durable") is true:
		set {_item} to lime wool named "&eDurable"
	set line 1 of {_item}'s lore to "&6Maximum Health is increased by 25%%"
	set slot 31 of {_menu} to {_item}

	set {_item} to red wool named "&7Tree Feller"
	if hasResearch({_player}, "tree_feller") is true:
		set {_item} to lime wool named "&eTree Feller"
	set line 1 of {_item}'s lore to "&6You cut trees down instantly"
	set slot 32 of {_menu} to {_item}

on inventory click:
	event-inventory is not event-player's inventory
	name of event-inventory is "&cWarrior Research"
	cancel event

	if index of event-slot is 30:
		if hasResearch(player, "master_smith") is true:
			deleteResearch(player, "master_smith")
		else:
			addResearch(player, "master_smith")
	if index of event-slot is 31:
		if hasResearch(player, "durable") is true:
			deleteResearch(player, "durable")
		else:
			addResearch(player, "durable")
	if index of event-slot is 32:
		if hasResearch(player, "tree_feller") is true:
			deleteResearch(player, "tree_feller")
		else:
			addResearch(player, "tree_feller")

	populateWarriorResearchMenu(player, event-inventory)

on mine of any log:
	hasClass(player, "warrior") is true
	player's tool is an axe
	if hasResearch(player, "tree_feller") is true:
		cancel the event
		fellTree(event-block)

function fellTree(block: block, depth: number=1):
	if {_depth} is greater than 300:
		exit
	if {_block} is not any log or any leaves:
		exit

	set {_recurse} to false
	{_block} is any log:
		set {_recurse} to true
		
	break {_block} naturally using a diamond axe
		
	if {_recurse} is true:
		loop blocks in radius 1.99 of {_block}:
			fellTree(loop-block, {_depth} + 1)

on preparing craft:
	hasClass(player, "warrior") is true
	if hasResearch(player, "master_smith") is true:
		event-item is any sword:
			enchant the event-slot with sharpness 1
		event-item is any pickaxe:
			enchant the event-slot with efficiency 1
		event-item is any axe:
			enchant the event-slot with efficiency 1
		event-item is any shovel:
			enchant the event-slot with unbreaking 1
		event-item is any hoe:
			enchant the event-slot with unbreaking 1
		event-item is any armor:
			enchant the event-slot with protection 1

on right click:
	hasClass(player, "warrior") is true

	if shouldTriggerAbility(player) is false:
		stop

	set {_didHit} to false
	set {_can_power_attack} to false
	
	if {rpgSkript::%player%::powerattack_time} is not set:
		set {_can_power_attack} to true
	if difference between now and {rpgSkript::%player%::powerattack_time} is more than 4 seconds:
		set {_can_power_attack} to true

	if {_can_power_attack} is true:
		player is holding a sword:
			loop all monsters in radius 5 around player:
				set {_didHit} to true
				apply slowness 3 to loop-monster for 7 seconds replacing the existing effect
				damage loop-entity by 3
				set {_vec} to normalized vector between player and loop-entity
				push loop-entity {_vec} with force 0.9
				push loop-entity upwards with force 0.6
				
		player is holding an axe:
			set {_loc} to the location 2 meters below and 3 meters horizontally behind the player
			set {_vec} to normalized vector between {_loc} and player
			loop all monsters in radius 5 around player:
				set {_didHit} to true
				apply slowness 3 to loop-monster for 7 seconds replacing the existing effect
				damage loop-entity by 2
				push loop-entity {_vec} with force 1.2
		
		player is holding a pickaxe:
			distance between player and player's targeted block is less than 5:
				create an explosion with force 0 at player's targeted block
				loop all blocks in radius 2 around player's targeted block:
					loop-block is not bedrock:
						set {_didHit} to true
						break loop-block naturally using player's held item

		if {_didHit} is true:
			set {rpgSkript::%player%::powerattack_time} to now
			apply slowness 3 to player for 4 seconds replacing the existing effect
			send action bar "&c&lPOWER ATTACK" to the player
				
	else:
		send action bar "&cYour power attack is still on cooldown!" to the player



# Rogue



function canUseRogueAbilities(player: player) :: boolean:
	if {_player} has potion effect slowness:
		return false
	if hasResearch({_player}, "fit") is true:
		if isWearingMediumOrLess({_player}) is true:
			return true
		return false
	else:
		if isWearingLightOrLess({_player}) is true:
			return true
		return false

command /rogueresearch:
	executable by: players
	trigger:
		hasClass(player, "rogue") is false:
			send "&dYou are not a rogue!"
			exit
		set {_menu} to a new chest inventory with 6 rows named "&aRogue Research"
		
		populateRogueResearchMenu(player, {_menu})
		
		open {_menu} to player

function populateRogueResearchMenu(player: player, menu: inventory):
	set {_item} to red wool named "&7Fit"
	if hasResearch({_player}, "fit") is true:
		set {_item} to lime wool named "&eFit"
	set line 1 of {_item}'s lore to "&6You may now wear Medium armor"
	set slot 31 of {_menu} to {_item}

on inventory click:
	event-inventory is not event-player's inventory
	name of event-inventory is "&aRogue Research"
	cancel event
	
	if index of event-slot is 31:
		if hasResearch(player, "fit") is true:
			deleteResearch(player, "fit")
		else:
			addResearch(player, "fit")

	populateRogueResearchMenu(player, event-inventory)

on death of a monster:
	attacker is a player
	hasClass(attacker, "rogue") is true
	set {_x} to a random number between 0 and 1000
	if {_x} <= 350:
		add 3 arrows to the drops
	if {_x} <= 80:
		add 1 raw gold to the drops
	if {_x} <= 45:
		add 1 diamond to the drops

on death of an animal:
	attacker is a player:
		hasClass(attacker, "rogue") is true:
			set {_x} to a random number between 0 and 1000
			if {_x} < 80:
				add 2 leather to the drops
		hasClass(attacker, "druid") is true:
			if {rpgSkript::%attacker%::wolfshape} is true:
				chance of 20%:
					send "&aYour Wolf Powers increase your spoils earned from the hunt!" to the attacker
					if victim is a sheep:
						add 3 raw mutton to the drops
						chance of 40%:
							add 2 wool to the drops
					if victim is a pig:
						add 3 raw pork to the drops
					if victim is a cow:
						add 3 raw beef to the drops
						chance of 40%:
							add 2 leather to the drops
					if victim is a horse:
						add 3 leather to the drops
					if victim is a donkey:
						add 3 leather to the drops
					if victim is a spider:
						add 2 spider eye to the drops	
					if victim is a bee:
						add 2 honeycomb to the drops
					if victim is a chicken:
						add 3 raw chicken to the drops
						chance of 40%:
							add 2 feather to the drops
						chance of 10%:
							add 2 egg to the drops
					add 5 experience to the attacker
					
	isMinion(attacker) is true:
		set {_caster} to getSummoner(uuid of attacker)
		hasClass({_caster}, "druid") is true:
			chance of 10%:
				send "&aYour God increases your spoils from the hunt!" to {_caster}
				if victim is a sheep:
					add 2 raw mutton to the drops
				if victim is a pig:
					add 2 raw pork to the drops
				if victim is a cow:
					add 2 raw beef to the drops
					chance of 20%:
						add 1 leather to the drops
				if victim is a horse:
					add 2 leather to the drops
				if victim is a spider:
					add 1 spider eye to the drops	
				if victim is a bee:
					add 1 honeycomb to the drops
				if victim is a chicken:
					add 2 raw chicken to the drops

on death of a player:
	hasClass(victim, "rogue") is true:
		keep the items
		clear drops
		send "&aYou may have died, but they'll never get your items!" to the victim
		stop
	loop the drops:
		hasLore(loop-item, "ethereal") is true:
			remove loop-item from the drops
			add loop-item to {rpgSkript::onRespawn::%victim%::*}

on respawn:
	loop {rpgSkript::onRespawn::%player%::*}:
		give loop-value to the player
	delete {rpgSkript::onRespawn::%player%::*}


# Herobrine?



on death of a player:
	hasClass(victim, "herobrine") is true:
		keep the items and experience
		clear drops
		send "&7Using your dark powers, you vanish!" to the victim
		play sound "entity.ender_dragon.death" with pitch 0.5 at victim

every 1 seconds:
	loop all players:
		hasClass(loop-player, "herobrine") is true:
			sunlight level at the loop-player is greater than 10:
				time in world of loop-player is not between 19:00 and 5:00:
					ignite the loop-player for 5 seconds
					send action bar "&4The daylight burns!" to loop-player
					damage loop-player by 12
		hasClass(loop-player, "endwarden") is true:
			if block at loop-player is water:
				send action bar "&4The water damages your ender skin!" to loop-player
				damage loop-player by maximum health of loop-player / 8
				apply slowness 1 to loop-player for 5 seconds replacing the existing effect
				apply weakness 1 to loop-player for 8 seconds replacing the existing effect		
			if weather in world of loop-player is rain:
				sunlight level at the loop-player is 15:
					send action bar "&4The rain damages your ender skin!" to loop-player
					damage loop-player by maximum health of loop-player / 8	
					apply slowness 1 to loop-player for 5 seconds replacing the existing effect
					apply weakness 1 to loop-player for 8 seconds replacing the existing effect


# Wizard



on place of lightning rod:
	add event-block to {rpgSkript::lightning_rod::*}
	rpgLog("%player% placed lightning rod in %world% at %location of block%")
	send "&dThis lightning rod will catch lightning from magic as well!" to event-player

on break of lightning rod:
	remove event-block from {rpgSkript::lightning_rod::*}
	rpgLog("%player% broke lightning rod in %world% at %location of block%")

function isLightningRodWithinRangeOf(loc: location, range: number, strike: boolean=false) :: boolean:
	loop blocks in {rpgSkript::lightning_rod::*}:
		if loop-block is not lightning rod:
			remove loop-block from {rpgSkript::lightning_rod::*}
			rpgLog("lightning rod was listed at %{_loc}%, but block was not actually a lightning rod")
		else if loop-block is within {_range} meters of {_loc}:
			if {_strike} is true:
				create lightning effect at loop-block
			return true
		return false

function setupMana(player: player):
	if {rpgSkript::mana::%{_player}%} is not set:
		set {rpgSkript::mana::%{_player}%} to 0
	if {rpgSkript::maxMana::%{_player}%} is not set:
		set {rpgSkript::maxMana::%{_player}%} to 0

	set {_newMax} to 0
	if hasClass({_player}, "herobrine") is true:
		set {_newMax} to (getPlayerLevel({_player})) * 45
	else if hasClass({_player}, "wizard") is true:
		if isWearingLightOrLess({_player}) is true:
			set {_newMax} to (getPlayerLevel({_player})) * 9
		else if isWearingMediumOrLess({_player}) is true:
			set {_newMax} to (getPlayerLevel({_player})) * 5
		else:
			set {_newMax} to (getPlayerLevel({_player})) * 1.5
	else if hasClass({_player}, "necromancer") is true:
		set {_newMax} to (getPlayerLevel({_player})) * 6 + 10
	else if hasClass({_player}, "sorceror") is true:
		set {_newMax} to 400
	else if hasClass({_player}, "druid") is true:
		set {_newMax} to (getPlayerLevel({_player})) * 6 + 10
	else if hasClass({_player}, "endwarden") is true:
		if {_player} is holding an ender pearl in offhand:
			set {_newMax} to (getPlayerLevel({_player})) * 6 + 22
		else:
			set {_newMax} to (getPlayerLevel({_player})) * 5 + 15
	else if hasClass({_player}, "cleric") is true:
		set {_newMax} to 1000
	else if hasClass({_player}, "artificer") is true:
		set {_newMax} to getMaxArtificerMana({_player})
	else if hasClass({_player}, "paladin") is true:
		set {_newMax} to 30

	if hasImbue({_player}, "Mana Boost") is true:
		set {_newMax} to {_newMax} + 0.25 * {_newMax} * countImbue({_player}, "Mana Boost")

	set {_newMax} to floor({_newMax})
	if {_newMax} is not {rpgSkript::maxMana::%{_player}%}:
		set {rpgSkript::maxMana::%{_player}%} to {_newMax}
		send "&3Your maximum mana has changed to %{_newMax}%" to {_player}

function checkMana(player: player):
	setupMana({_player})
	if {rpgSkript::mana::%{_player}%} > {rpgSkript::maxMana::%{_player}%}:
		set {rpgSkript::mana::%{_player}%} to {rpgSkript::maxMana::%{_player}%}
	if {rpgSkript::mana::%{_player}%} < 0:
		set {rpgSkript::mana::%{_player}%} to 0

function regenMana(player: player):
	if {rpgSkript::mana::%{_player}%} is not set:
		setupMana({_player})
	if {rpgSkript::maxMana::%{_player}%} is not set:
		setupMana({_player})

	set {_add} to 0
	if hasClass({_player}, "herobrine") is true:
		set {_add} to {rpgSkript::maxMana::%{_player}%} / 100
	else if hasClass({_player}, "wizard") is true:
		if isWearingLightOrLess({_player}) is true:
			set {_add} to {rpgSkript::maxMana::%{_player}%} / 40
		else if isWearingMediumOrLess({_player}) is true:
			set {_add} to {rpgSkript::maxMana::%{_player}%} / 70
	else if hasClass({_player}, "sorceror") is true:
		set {_add} to {rpgSkript::maxMana::%{_player}%} / 55
	else if hasClass({_player}, "necromancer") is true:
		set {_add} to {rpgSkript::maxMana::%{_player}%} / 20
	else if hasClass({_player}, "druid") is true:
		set {_add} to {rpgSkript::maxMana::%{_player}%} / 20
	else if hasClass({_player}, "endwarden") is true:
		set {_add} to {rpgSkript::maxMana::%{_player}%} / 20
	else if hasClass({_player}, "artificer") is true:
		set {_add} to {rpgSkript::maxMana::%{_player}%} / 10
	else if hasClass({_player}, "cleric") is true:
		set {_add} to {rpgSkript::maxMana::%{_player}%} / 200
	else if hasClass({_player}, "paladin") is true:
		set {_add} to {rpgSkript::maxMana::%{_player}%} / 6

	if hasImbue({_player}, "photosynthesis") is true:
		sun light level at {_player} is greater than 5:
			time in world of {_player} is not between 19:00 and 5:00:
				set {_add} to {_add} * ( 1 + 0.1 * countImbue({_player}, "photosynthesis"))
	
	addMana( {_player}, {_add} )

function addMana(player: player, amount: number):
	set {_before} to {rpgSkript::mana::%{_player}%}
	set {rpgSkript::mana::%{_player}%} to {rpgSkript::mana::%{_player}%} + {_amount}
	checkMana({_player})
	if abs( {rpgSkript::mana::%{_player}%} - {_before} ) > 0.01:
		displayMana({_player})

function subMana(player: player, amount: number, print: boolean=true) :: boolean:
	{_player} has permission "rpg.control":
		return true
	if {rpgSkript::mana::%{_player}%} is not set:
		return false
	if hasMana({_player}, {_amount}, {_print}) is true:
		set {rpgSkript::mana::%{_player}%} to {rpgSkript::mana::%{_player}%} - {_amount}
		checkMana({_player})
		displayMana({_player})
		return true
	else:
		return false

function hasMana(player: player, amount: number, print: boolean=true) :: boolean:
	{_player} has permission "rpg.control":
		return true
	if {_print} is true:
		send "&3Mana: Have %{rpgSkript::mana::%{_player}%}%, Need %{_amount}%" to {_player}
	if {rpgSkript::mana::%{_player}%} - {_amount} > -0.01:
		return true
	return false

function displayMana(player: player):
	set {_dispM} to {rpgSkript::mana::%{_player}%}
	if {_dispM} < 0:
		set {_dispM} to 0
	send action bar "&3Mana: %{_dispM}% / %{rpgSkript::maxMana::%{_player}%}%" to {_player}

function hasItems(player: player, items: items) :: boolean:
	{_player} has permission "rpg.control":
		return true
	{_player} has {_items::*}:
		return true
	return false

function takeItems(player: player, items: items) :: boolean:
	{_player} has permission "rpg.control":
		return true
	if hasItems({_player}, {_items::*}) is true:
		remove {_items::*} from {_player}
		scriptConsoleMessage("Took items from %{_player}%: %{_items::*}%")
		return true
	return false

function hasResources(player: player, mana: number, items: items) :: boolean:
	{_player} has permission "rpg.control":
		return true
	send "&3Items - Need: %{_items::*}%" to {_player}
	if hasItems({_player}, {_items::*}) is true:
		hasMana({_player}, {_mana}) is true:
			return true
	return false

function takeResources(player: player, mana: number, items: items) :: boolean:
	{_player} has permission "rpg.control":
		return true
	if hasResources({_player}, {_mana}, {_items::*}) is true:
		takeItems({_player}, {_items::*})
		subMana({_player}, {_amount})
		return true
	return false

function arcaneSense(message: text):
	loop all players:
		hasClass(loop-player, "wizard") is true:
			send "&d%{_message}%" to loop-player

on death of a player:
    hasClass(victim, "wizard") is true:
        keep the experience
        send "&dYou use your magic powers to keep your experience!" to the victim		

command /imbue <text>:
	description: Imbue an item with powerful magic properties
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if subMana(player, 1000) is false:
			send "&cYou do not have enough mana to imbue an item with magic!"
			stop
		if arg 1 is "health":
			if takeItems( player, getItemCostForImbue("health") ) is true:
				set line lastLoreLine(player's held item) of (player's held item)'s lore to "&cHealth Boost"
				send "&dYou imbue the item in your hand with Health Boost!"
			else:
				send "&cYou do not have the required items for that property!"
				stop
		else if arg 1 is "mana":
			if takeItems( player, getItemCostForImbue("mana")) is true:
				set line lastLoreLine(player's held item) of (player's held item)'s lore to "&3Mana Boost"
				send "&dYou imbue the item in your hand with Mana Boost!"
			else:
				send "&cYou do not have the required items for that property!"
				stop
		else:
			send "&cThat is not a valid property!"
			stop

command /arcane <text>:
	description: Send a message to be magically received by wizards
	permission: rpg.control
	permission message: You do not have permission for that command
	trigger:
		arcaneSense(arg 1)

command /send <player>:
	description: Magically send what you are holding to another player!
	executable by: players
	trigger:
		( hasClass(player, "wizard") or hasClass(player, "sorceror") ) is true
		set {_senditem} to held item of player
		{_senditem} is air:
			message "&cYou can't send air!"
			stop
		if arg 1 hasn't enough space for {_senditem}:
			message "&cThe recipient doesn't have enough inventory space!"
			stop
		if subMana(command executor, 75) is false:
			message "&cYou do not have enough Mana!"
			stop
		set {_sendItemList::*} to ( {_senditem} )
		takeItems(player, {_sendItemList::*})
		giveItem(arg 1, {_sendItem})
		message "&3Sent %{_senditem}% to %arg 1%"
		send "&a[Send] %player% Sent %{_senditem}% to %arg 1%" to console
		send "&3Received %{_senditem}% from %player%" to arg 1

command /remember <text>:
	description: Remember your current location, to recall it later
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if subMana(command executor, 5) is false:
			message "&cYou do not have enough Mana!"
			stop
		if {rpgSkript::%command executor%::memory::%arg 1%} is set:
			message "&cYou already know a location by that name!"
			stop
		set {rpgSkript::%command executor%::memory::%arg 1%} to command executor's location
		message "&dYou take note of your surroundings, so that you may magically return later..."

command /forget <text>:
	description: Forget a location
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		delete {rpgSkript::%command executor%::memory::%arg 1%}
		message "&dYou remove the location from memory..."

command /recall <text>:
	description: Teleport to a location that you remember
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if {rpgSkript::%command executor%::memory::%arg 1%} is set:
			if subMana(command executor, 130) is false:
				message "&cYou do not have enough Mana!"
				stop
			play sound "entity.enderman.teleport" at command executor
			show smoke at command executor
			teleport command executor to {rpgSkript::%command executor%::memory::%arg 1%}
			show smoke at command executor
			play sound "entity.enderman.teleport" at command executor
			message "&dYou recall a location from memory!"
		else:
			message "&dYou do not remember any such location"

command /sendnear <text>:
	description: Teleport nearby players to a location that you remember
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if {rpgSkript::%command executor%::memory::%arg 1%} is set:
			if subMana(command executor, 80) is false:
				message "&cYou do not have enough Mana!"
				stop
			loop entities in radius 7 of player:
				loop-entity is a player
				loop-entity is not command executor
				play sound "entity.enderman.teleport" at loop-entity
				show smoke at loop-entity
				teleport loop-entity to {rpgSkript::%command executor%::memory::%arg 1%}
			message "&dYou send nearby players to a location that you remember!"
		else:
			message "&dYou do not remember any such location"

command /memories:
	description: List locations that you remember
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		loop {rpgSkript::%command executor%::memory::*}:
			message loop-index

command /pocket:
	description: Open your enderchest
	executable by: players
	trigger:
		hasClass(player, "wizard") is true
		if subMana(command executor, 20) is false:
			send "&cYou do not have enough Mana to cast the pocket spell!" to command executor
			stop
		send "&dYou open a rift and reach into your enderchest!" to command executor
		play sound "entity.enderman.teleport" at command executor
		make command executor run command "/enderchest" as op

command /cast <text>:
	description: Cast a spell
	executable by: players
	trigger:
		( hasClass(player, "wizard") or hasClass(player, "sorceror") ) is true
		if arg 1 is "conjure":
			if subMana(command executor, 1500) is false:
				send "&cYou do not have enough Mana to cast the conjure spell!" to command executor
				stop
			send "&dYou whisper, and an iron golem materializes into existence!" to command executor
			spawn 1 iron golem at the location 1 meter above command executor's targeted block
		if arg 1 is "safe":
			if subMana(command executor, 20) is false:
				send "&cYou do not have enough Mana to cast the magic safe spell!" to command executor
				stop
			set {_inv} to chest inventory with 6 rows named "&dSafe"
			send "&dYou open a rift and reach into a magical safe!" to command executor
			play sound "entity.enderman.teleport" at command executor
			loop 6*9 times:
				set slot (loop-value)-1 of {_inv} to {rpgSkript::%player%::safe::%loop-value%}
			open {_inv} to player
		if arg 1 is "fireball":
			if subMana(command executor, 220) is false:
				send "&cYou do not have enough Mana to cast the fireball spell!" to command executor
				stop
				
			set {_c} to 1
			while {_x} is not set:
				if {-rpgSkript::fireballs::%{_c}%} is not set:
					set {_x} to {_c}
					set {-rpgSkript::fireballs::%{_x}%} to "fireball"
				else:
					set {_c} to {_c} + 1
					
			set {_loc} to the command executor's location
			set {_loc} to the location 1.6 meters above {_loc}
			
			set {_v} to vector from yaw (yaw of command executor) and pitch (pitch of command executor)
			set {_v} to normalized {_v}
			set the vector length of {_v} to 4
			
			set {_first} to {_v}
			set vector length of {_first} to 4
			
			set {_loc} to ( {_loc} ~ {_first} )
			
			set {-rpgSkript::fireballs::%{_x}%::loc} to {_loc}
			set {-rpgSkript::fireballs::%{_x}%::v} to {_v}
			set {-rpgSkript::fireballs::%{_x}%::time} to now
			set {-rpgSkript::fireballs::%{_x}%::caster} to player
			set {-rpgSkript::fireballs::%{_x}%} to 1
			play sound "item.firecharge.use" with pitch 0.7 at command executor
			send "&dYou unleash a sphere of fiery destruction!" to command executor

command /fireballs:
	trigger:
		command executor has permission "rpg.control":
			set {_x} to 0
			loop {-rpgSkript::fireballs::*}:
				set {_x} to {_x} + 1
			send "&cFireballs: %{_x}%" to command executor

every tick:
	loop {-rpgSkript::fireballs::*}:
		set {_loc} to {-rpgSkript::fireballs::%loop-index%::loc}

		if difference between {-rpgSkript::fireballs::%loop-index%::time} and now is greater than 10 seconds:
			delete {-rpgSkript::fireballs::%loop-index%}

		y of (vector of {_loc}) is greater than 300:
			explodeFireball(loop-index)
			rpgLog("Cleared stray fireball")
			continue
		y of (vector of {_loc}) is less than -300:
			explodeFireball(loop-index)
			rpgLog("Cleared stray fireball")
			continue

		set {_delta} to {-rpgSkript::fireballs::%loop-index%::v}
		set vector length of {_delta} to 0.25
		set {_distance} to vector length of {-rpgSkript::fireballs::%loop-index%::v}
		while {_distance} > 0.25:
			moveFireball(loop-index, {_delta})
			set {_distance} to {_distance} - 0.25
		set vector length of {_delta} to {_distance}
		moveFireball(loop-index, {_delta})

function moveFireball(index: string, v: vector):
	if {-rpgSkript::fireballs::%{_index}%} is not set:
		exit
	show large smoke at ({-rpgSkript::fireballs::%{_index}%::loc})
	set {-rpgSkript::fireballs::%{_index}%::loc} to ({-rpgSkript::fireballs::%{_index}%::loc} ~ {_v})
	set {_loc} to {-rpgSkript::fireballs::%{_index}%::loc}
	show mob spawner flames at {_loc}
	loop blocks in radius 1 around {_loc}:
		loop-block is water:
			delete {-rpgSkript::fireballs::%{_index}%}
		loop-block is solid:
			explodeFireball({_index})
	loop all entities in radius 2 around {_loc}:
		loop-entity is not a dropped item:
			explodeFireball({_index})

function explodeFireball(index: string):
	if {-rpgSkript::fireballs::%{_index}%} is not set:
		exit
	set {_loc} to {-rpgSkript::fireballs::%{_index}%::loc}
	playSoundToPlayers({_loc}, "entity.firework_rocket.blast", 90, 0.3)
	explodeRadius(block at {_loc}, 1.5)
	loop blocks in radius 2.5 around {_loc}:
		loop-block is air:
			show mob spawner flames at loop-block
	loop blocks in radius 5 around {_loc}:
		loop-block is air:
			set block at location of loop-block to fire
	delete {-rpgSkript::fireballs::%{_index}%}
	loop all entities in radius 8 around ({_loc}):
		loop-entity is not a dropped item
		damage loop-entity by 60
	create an explosion with force 3 at {_loc}
	if {-rpgSkript::fireballs::%{_index}%::caster} is set:
		add 5 experience to {-rpgSkript::fireballs::%{_index}%::caster}

every tick:
	loop {-rpgSkript::cryoballs::*}:
		set {_loc} to {-rpgSkript::cryoballs::%loop-index%::loc}

		if difference between {-rpgSkript::cryoballs::%loop-index%::time} and now is greater than 10 seconds:
			delete {-rpgSkript::cryoballs::%loop-index%}

		y of (vector of {_loc}) is greater than 300:
			explodeCryoball(loop-index)
			rpgLog("Cleared stray cryoball")
			continue
		y of (vector of {_loc}) is less than -300:
			explodeCryoball(loop-index)
			rpgLog("Cleared stray cryoball")
			continue

		set {_delta} to {-rpgSkript::cryoballs::%loop-index%::v}
		set vector length of {_delta} to 0.25
		set {_distance} to vector length of {-rpgSkript::cryoballs::%loop-index%::v}
		while {_distance} > 0.25:
			moveCryoball(loop-index, {_delta})
			set {_distance} to {_distance} - 0.25
		set vector length of {_delta} to {_distance}
		moveCryoball(loop-index, {_delta})
		set {-rpgSkript::cryoballs::%loop-index%::v} to {-rpgSkript::cryoballs::%loop-index%::v} -- (vector 0,0.1,0)

function moveCryoball(index: string, v: vector):
	if {-rpgSkript::cryoballs::%{_index}%} is not set:
		exit
	set {-rpgSkript::cryoballs::%{_index}%::loc} to ({-rpgSkript::cryoballs::%{_index}%::loc} ~ {_v})
	set {_loc} to {-rpgSkript::cryoballs::%{_index}%::loc}
	show water splash at {_loc}
	loop blocks in radius 1 around {_loc}:
		show cloud at loop-block
		show water splash at {_loc}
		loop-block is water:
			explodeCryoball({_index})
		loop-block is lava:
			explodeCryoball({_index})
		loop-block is solid:
			explodeCryoball({_index})
	loop all entities in radius 2 around {_loc}:
		loop-entity is not a dropped item:
			explodeCryoball({_index})

function explodeCryoball(index: string):
	if {-rpgSkript::cryoballs::%{_index}%} is not set:
		exit
	set {_loc} to {-rpgSkript::cryoballs::%{_index}%::loc}
	playSoundToPlayers({_loc}, "entity.firework_rocket.blast", 50, 0.7)
	loop blocks in radius 4 around {_loc}:
		loop-block is air:
			show cloud at loop-block
		loop-block is water:
			set loop-block to ice
		loop-block is lava:
			set loop-block to cobblestone
	loop blocks in radius 10 around {_loc}:
		loop-block is fire:
			set loop-block to air
	delete {-rpgSkript::cryoballs::%{_index}%}
	loop all entities in radius 14 around ({_loc}):
		loop-entity is not a dropped item
		damage loop-entity by 3
		apply slowness 3 to loop-entity for 8 seconds replacing the existing effect
	if {-rpgSkript::cryoballs::%{_index}%::caster} is set:
		add 3 experience to {-rpgSkript::cryoballs::%{_index}%::caster}

on inventory close:
	if event-inventory's name is "&dSafe":
		loop 6*9 times:
			set {rpgSkript::%player%::safe::%loop-value%} to slot (loop-value)-1 of event-inventory

on right click with stick:
	player's held item is not a plain stick:
		stop trigger
	( hasClass(player, "wizard") or hasClass(player, "sorceror") ) is true
	if subMana(event-player, 5) is false:
		send "&cYou do not have enough Mana to cast the firebolt spell!" to event-player
		stop
	send "&dYou hurl a mote of fire!" to event-player
	play sound "item.firecharge.use" at event-player
	make player run command "/fireball" as op
	add 2 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)

on right click with gunpowder:
	( hasClass(player, "wizard") or hasClass(player, "sorceror") ) is true
	if subMana(event-player, 100) is false:
		send "&cYou do not have enough Mana to cast the explosion spell!" to event-player
		stop
	send "&dYou speak words of arcane significance and create a powerful explosion!" to event-player
	play sound "item.firecharge.use" at event-player
	loop all entities in radius 8 around (event-player's targeted block):
		loop-entity is not a dropped item
		damage loop-entity by 24
		add 4 experience to the player
	create an explosion with force 5 at the event-player's targeted block
	add 10 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)

on right click with nether quartz:
	( hasClass(player, "wizard") or hasClass(player, "sorceror") ) is true
	if subMana(event-player, 200) is false:
		send "&cYou do not have enough Mana to cast the smite spell!" to event-player
		stop
	send "&dYou strike monsters with lightning!" to event-player
	play sound "entity.player.breath" with pitch 0.7 at player
	loop all entities in radius 12 around (event-player's targeted block):
		loop-entity is not a dropped item
		loop-entity is not a player
		isMonster(loop-entity) is true
		loop-entity's health is greater than 0
		create lightning effect at the loop-entity
		damage loop-entity by 8
		add 5 experience to the player
	add 14 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)

on right click with iron nugget:
	true is false # This spell is disabled
	( hasClass(player, "wizard") or hasClass(player, "sorceror") ) is true
	if subMana(event-player, 180) is false:
		send "&cYou do not have enough Mana to cast the shatter spell!" to event-player
		stop
	send "&dYou tear at the fabric of reality!" to event-player
	play sound "item.firecharge.use" at event-player
	loop all blocks in radius 15 around (event-player's targeted block):
		chance of 0.3%:
			loop-block is not air
			create an explosion with force 3 at the loop-block
			wait 1 ticks
	add 10 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)

on right click with magma cream:
	( hasClass(player, "wizard") or hasClass(player, "sorceror") ) is true
	make player execute command "/cast fireball"

on right click with flint:
	( hasClass(player, "wizard") or hasClass(player, "sorceror") ) is true
	if subMana(event-player, 18) is false:
		send "&cYou do not have enough Mana to cast the ignite spell!" to event-player
		stop
	send "&dYou draw energy from the item in your hand and light creatures on fire!" to event-player
	play sound "item.flintandsteel.use" at event-player
	loop all entities in radius 13 around (event-player's targeted block):
		loop-entity is not a dropped item
		loop-entity is not player
		ignite loop-entity for 10 seconds
		show mob spawner flames at (the location 1 block above the loop-entity's location)
		add 1 experience to the player
	add 4 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)

on right click with blaze rod:
	hasClass(player, "wizard") is true
	if subMana(event-player, 1000) is false:
		send "&cYou do not have enough Mana to cast the devastating blast spell!" to event-player
		stop
	send "&dYou shout, and your thunderous words are met with an equally powerful blast of destruction!" to event-player
	set {_block} to event-player's targeted block
	play sound "item.firecharge.use" at event-player
	loop all entities in radius 50 around {_block}:
		loop-entity is not a dropped item
		loop-entity is not the player
		set {_vec} to the vector between {_block} and the loop-entity
		set {_vec} to normalized {_vec}
		push loop-entity {_vec} with force 2
		damage loop-entity by 200
		add 16 experience to the player
	create an explosion with force 0 at {_block}
	explodeRadius({_block}, 13)
	wait 5 ticks
	create an explosion with force 38 at {_block}
	add 32 experience to the player
	show mob spawner flames at (the location 1 block above the player's location)
	create a fake explosion at the player

on right click with diamond:
	( hasClass(player, "wizard") or hasClass(player, "sorceror") ) is true
	if subMana(event-player, 300) is false:
		send "&cYou do not have enough Mana to cast the lightning spell!" to event-player
		stop
	send "&dYou conjure an enormous bolt of lighting from the heavens!" to event-player
	if isLightningRodWithinRangeOf(location of event-player's targeted block, 150, true) is true:
		send "&dYou sense that your lightning as been absorbed by a lightning rod!"
		stop
	loop all entities in radius 22 around (event-player's targeted block):
		loop-entity is not a dropped item
		loop-entity is not the player
		damage loop-entity by 90
		add 12 experience to the player
	create lightning effect at the event-player's targeted block
	create an explosion with force 12 at the event-player's targeted block
	add 24 experience to the player
	play sound "entity.player.breath" with pitch 0.7 at player

on right click with feather:
	( hasClass(player, "wizard") or hasClass(player, "cleric") ) is true
	set {_amount} to 2
	hasClass(player, "cleric") is true:
		set {_amount} to 4
	set {_t} to targeted entity of player
	{_t} is a player:
		if subMana(event-player, 150) is false:
			send "&cYou do not have enough Mana to cast the heal other spell!" to event-player
			stop
		heal({_t}, {_amount})
		send "&6You heal %{_t}%!" to event-player
		send "&6You are healed!" to {_t}
		play sound "entity.player.levelup" with pitch 1.5 at {_t}
		stop
	if subMana(event-player, 150) is false:
		send "&cYou do not have enough Mana to cast the heal spell!" to event-player
		stop
	heal(event-player, {_amount})
	send "&6You heal yourself!" to event-player
	play sound "entity.player.levelup" with pitch 1.5 at event-player

on right click with amethyst shard:
	hasClass(player, "wizard") is true
	set {_loc} to event-player's targeted block
	set {_loc} to location 1 meter above {_loc}
	set pitch of {_loc} to pitch of event-player
	set yaw of {_loc} to yaw of event-player

	set {_canTp} to true
	if block at {_loc} is solid:
		set {_canTp} to false
	if block 1 meter above {_loc} is solid:
		set {_canTp} to false
	if {_canTp} is false:
		send "&cCannot blink there!" to event-player
		stop

	if subMana(event-player, 80) is false:
		send "&cYou do not have enough Mana to cast the blink spell!" to event-player
		stop
	send "&dYou blink to your target location!" to event-player
	play sound "entity.enderman.teleport" at event-player
	teleport event-player to {_loc}
	add 1 experience to the event-player
	wait 2 ticks
	play sound "entity.enderman.teleport" at event-player

on right click with clay ball:
	hasClass(player, "wizard") is true
	if subMana(event-player, 50) is false:
		send "&cYou do not have enough Mana to cast the move monsters spell!" to event-player
		stop
	send "&dSummoned nearby monsters near where you are looking!" to event-player
	set {_loc} to event-player's targeted block
	loop all entities in radius 60 around (event-player's targeted block):
		loop-entity is not a dropped item
		loop-entity is not a player
		teleport loop-entity to location 1 meter above {_loc}
		add 1 experience to the player
	add 2 experience to the player
	play sound "entity.player.breath" with pitch 0.7 at player

on right click with sugar:
	hasClass(player, "wizard") is true
	if subMana(event-player, 30) is false:
		send "&cYou do not have enough Mana to cast the move items spell!" to event-player
		stop
	set {_loc} to event-player's targeted block
	loop all entities in radius 80 around (event-player's targeted block):
		loop-entity is a dropped item
		teleport loop-entity to location 1 meter above {_loc}
	play sound "entity.player.breath" with pitch 0.7 at player
	send "&dSummoned nearby dropped items near where you are looking!" to event-player

on right click with wheat:
	if at least one of:
		hasClass(player, "wizard") is true
		hasClass(player, "druid") is true
	then:
		if subMana(event-player, 200) is false:
			send "&cYou do not have enough Mana to cast the harvest spell!" to event-player
			stop
		send "&dYou wave your hands and your crops have been magically harvested!" to event-player
		loop blocks in radius 50 of player:
			set {_loc} to location of loop-block
			loop-block is wheat:
				break loop-block naturally
				set loop-block to wheat
				wait 2 ticks
			loop-block is carrot plant:
				break loop-block naturally
				set loop-block to carrot plant
				wait 2 ticks
			loop-block is potato plant:
				break loop-block naturally
				set loop-block to potato plant
				wait 2 ticks
			loop-block is nether wart plant:
				break loop-block naturally
				set loop-block to nether wart plant
				wait 2 ticks
			loop-block is melon:
				break loop-block naturally
				wait 2 ticks
			loop-block is pumpkin:
				break loop-block naturally
				wait 2 ticks
			loop-block is bamboo:
				block 1 meter below loop-block is bamboo
				break loop-block naturally
				wait 2 ticks
			loop-block is sugar cane:
				block 1 meter below loop-block is sugar cane
				break loop-block naturally
				wait 2 ticks
			loop-block is sweet berry bush:
				loop-block's age is 3
				set loop-block's age to 1
				drop 3 sweet berry at {_loc}
				wait 2 ticks

command /wizardresearch:
	executable by: players
	trigger:
		hasClass(player, "wizard") is false:
			send "&dYou are not a wizard!"
			exit
		set {_menu} to a new chest inventory with 6 rows named "&dWizard Research"
		
		populateWizardResearchMenu(player, {_menu})
		
		open {_menu} to player

function populateWizardResearchMenu(player: player, menu: inventory):
	set {_item} to red wool named "&7Constant Study"
	if hasResearch({_player}, "power") is true:
		set {_item} to lime wool named "&eConstant Study"
	set line 1 of {_item}'s lore to "&6Gain 3 experience every 2 seconds"
	set slot 31 of {_menu} to {_item}

on inventory click:
	event-inventory is not event-player's inventory
	name of event-inventory is "&dWizard Research"
	cancel event
	
	if index of event-slot is 31:
		if hasResearch(player, "power") is true:
			deleteResearch(player, "power")
		else:
			addResearch(player, "power")

	populateWizardResearchMenu(player, event-inventory)

on right click with lapis lazuli:
	( hasClass(player, "wizard") or hasClass(player, "sorceror") ) is true
	if subMana(command executor, 60) is false:
		send "&cYou do not have enough Mana to cast the cryoball spell!" to command executor
		stop
		
	set {_c} to 1
	while {_x} is not set:
		if {-rpgSkript::cryoballs::%{_c}%} is not set:
			set {_x} to {_c}
			set {-rpgSkript::cryoballs::%{_x}%} to "cryoball"
		else:
			set {_c} to {_c} + 1
			
	set {_loc} to the command executor's location
	set {_loc} to the location 1.6 meters above {_loc}
	
	set {_v} to vector from yaw (yaw of command executor) and pitch (pitch of command executor)
	set {_v} to normalized {_v}
	set the vector length of {_v} to 2
	
	set {_first} to {_v}
	set vector length of {_first} to 4
	
	set {_loc} to ( {_loc} ~ {_first} )
	
	set {-rpgSkript::cryoballs::%{_x}%::loc} to {_loc}
	set {-rpgSkript::cryoballs::%{_x}%::v} to {_v}
	set {-rpgSkript::cryoballs::%{_x}%::time} to now
	set {-rpgSkript::cryoballs::%{_x}%::caster} to player
	set {-rpgSkript::cryoballs::%{_x}%} to 1
	play sound "item.bucket.empty" with pitch 0.7 at command executor
	send "&dYou release a freezing orb of water!" to command executor



# Necromancer



function isMinion(entity: entity) :: boolean:
	{_entity} is a player:
		return false
	{-rpgSkript::minions::%uuid of {_entity}%} is set:
		return true
	return false

function getByUUID(uuid: text) :: entity:
	loop all living entities:
		uuid of loop-entity contains {_uuid}:
			return loop-entity

every 2 seconds:

	set {_start} to now

	loop {-rpgSkript::minions::*}:
	
		set {_uuid} to loop-index
		set {_entity} to getByUUID({_uuid})
		{_entity} is not set:
			deleteMinion({_uuid})
			continue loop
			
		set {_summoner} to {-rpgSkript::minions::%{_uuid}%::summoner}
		{_summoner} is not online:
			killMinion({_uuid})
			continue loop

		target of {_entity} is not set:
			loop living entities in radius 10 of {_entity}:
				if isMonster(loop-entity) is true:
					loop-entity is not {_summoner}:
						set target of {_entity} to loop-entity

		distance between {_entity} and {_summoner} is more than 15:
			make {_entity} pathfind towards {_summoner} at speed 1.3
			reset target of {_entity}

		if at least one of:
			distance between {_entity} and {_summoner} is more than 30
			{_entity}'s world is not {_summoner}'s world
		then:
			teleport {_entity} to {_summoner}
			make {_entity} stop pathfinding
			reset target of {_entity}

	set {_end} to now
	set {_seconds} to difference between {_end} and {_start}
	scriptDebugConsoleMessageType("minion_loop_time", "Took %{_seconds}%")

on death:
	the victim is not a player
	isMinion(the victim) is true:
		play sound "entity.player.breath" with pitch 1.5 at the victim
		deleteMinion(uuid of the victim)
		clear drops
	else:
		loop players in radius 50 of the victim:
			hasClass(loop-player, "necromancer") is true:
				add 1 experience to the loop-player

on explosion prime:
	event-entity is a creeper:
		isMinion(target of event-entity) is true:
			cancel the event

function deleteMinion(uuid: text):
	delete {-rpgSkript::minions::%{_uuid}%}
	delete {-rpgSkript::minions::%{_uuid}%::*}

	set {_entity} to getByUUID({_uuid})
	{_entity} is set:
		reset target of {_entity}

function killMinion(uuid: text):
	kill getByUUID({_uuid})
	deleteMinion({_uuid})

command /raise <text>:
	description: Raise a minion
	executable by: players
	trigger:
		hasClass(player, "necromancer") is true
		if arg 1 is "skeleton":
			if subMana(command executor, 10) is false:
				send "&cYou do not have enough Mana to raise a skeleton!" to command executor
				stop
			send "&dYou raise an undead skeleton!" to command executor
			set {_player} to the player
			spawn 1 skeleton at the player:
				setupMinion(the skeleton, {_player})
		if arg 1 is "warrior":
			if subMana(command executor, 10) is false:
				send "&cYou do not have enough Mana to raise a skeleton!" to command executor
				stop
			send "&dYou raise an undead skeleton!" to command executor
			set {_player} to the player
			spawn 1 skeleton at the player:
				set movement speed attribute of the skeleton to 1.3 * movement speed attribute of the skeleton
				set the skeleton's held item to iron sword
				setupMinion(the skeleton, {_player})

on right click with bone:
	hasClass(player, "necromancer") is true
	if subMana(command executor, 10) is false:
		send "&cYou do not have enough Mana to raise a skeleton!" to command executor
		stop
	send "&dYou raise an undead skeleton!" to command executor
	set {_player} to the player
	spawn 1 skeleton at the player:
		setupMinion(the skeleton, {_player})

on right click with rotten flesh:
	hasClass(player, "necromancer") is true
	if subMana(command executor, 10) is false:
		send "&cYou do not have enough Mana to raise a skeleton!" to command executor
		stop
	send "&dYou raise an undead skeleton!" to command executor
	set {_player} to the player
	spawn 1 skeleton at the player:
		set movement speed attribute of the skeleton to 1.3 * movement speed attribute of the skeleton
		set the skeleton's held item to iron sword
		setupMinion(the skeleton, {_player})

on left click with bone:
	hasClass(event-player, "necromancer") is true:
		play sound "entity.player.breath" with pitch 0.7 at player
		loop getMinions(event-player):
			event-player's targeted entity is not set:
				reset target of loop-value
				make loop-value pathfind to event-player's targeted block at speed 1.4
			event-player's targeted entity is set:
				set target of loop-value to event-player's targeted entity

function setupMinion(entity: entity, summoner: player):
	set {-rpgSkript::minions::%uuid of {_entity}%} to 1
	set {-rpgSkript::minions::%uuid of {_entity}%::summoner} to {_summoner}
	set {_entity}'s helmet to leather helmet
	dye {_entity}'s helmet blue
	enchant {_entity}'s helmet with protection 1
	reset target of {_entity}

function hasSameSummoner(entity: entity, entity2: entity) :: boolean:
	{-rpgSkript::minions::%uuid of {_entity}%::summoner} is {-rpgSkript::minions::%uuid of {_entity2}%::summoner}:
		return true
	return false

function getSummoner(uuid: text) :: player:
	{-rpgSkript::minions::%{_uuid}%::summoner} is set:
		return {-rpgSkript::minions::%{_uuid}%::summoner}

function getMinionCount(summoner: player) :: number:
	set {_count} to 0
	loop {-rpgSkript::minions::*}:
		getSummoner(loop-index) is {_summoner}:
			set {_count} to {_count} + 1
	return {_count}

function getMinionUUIDs(summoner: player) :: texts:
	loop {-rpgSkript::minions::*}:
		getSummoner(loop-index) is {_summoner}:
			add loop-index to {_list::*}
	return {_list::*}

function getMinions(summoner: player) :: entities:
	set {_uuids::*} to getMinionUUIDs({_summoner})
	loop {_uuids::*}:
		add getByUUID({_uuids::%loop-index%}) to {_list::*}
	return {_list::*}

function calculateMaxMinions(summoner: player) :: number:
	set {_count} to 0
	hasClass({_summoner}, "necromancer") is true:
		set {_count} to 4
		set {_count} to {_count} + getPlayerLevel({_summoner}) / 3
		{_count} is greater than 18:
			set {_count} to 18
		isWearingLightOrLess({_summoner}) is true:
			set {_count} to {_count} * 1.5
		return floor({_count})
	hasClass({_summoner}, "druid") is true:
		set {_count} to 1
	hasClass({_summoner}, "endwarden") is true:
		set {_count} to 1
		set {_count} to {_count} + getPlayerLevel({_summoner}) / 10
		{_count} is greater than 5:
			set {_count} to 5
		isWearingLightOrLess({_summoner}) is true:
			set {_count} to {_count} * 2.0

	return floor({_count})

function cullMinions(summoner: player):
	set {_toRemove} to getMinionCount({_summoner}) - calculateMaxMinions({_summoner})
	loop {-rpgSkript::minions::*}:
		{_toRemove} > 0:
			getSummoner(loop-index) is {_summoner}:
				killMinion(loop-index)
				set {_toRemove} to {_toRemove} - 1



# Cleric



on resurrect attempt:
	entity is a player:
		hasClass(player, "cleric") is true:
			chance of 30%:
				uncancel the event
				send "&6The gods save you from death!" to the player
				stop
			subMana(player, 500) is true:
				uncancel the event
				send "&6You use your divine powers to escape death!" to the player
				stop

on heal:
	event-entity is a player:
		hasClass(event-player, "cleric") is true:
			set the heal amount to the heal amount * 2
		scriptDebugBroadcastType("heal", "%player% heals for %heal amount%")

command /pray <text>:
	executable by: players
	trigger:
		hasClass(player, "cleric") is true
		{rpgSkript::%player%::lastPrayer} is not set:
			set {rpgSkript::%player%::lastPrayer} to 30 minutes ago
		difference between {rpgSkript::%player%::lastPrayer} and now is less than 2 minutes:
			send "&cYou must wait before you can pray again!" to player
			stop
		set {rpgSkript::%player%::lastPrayer} to now
		arg 1 is "food":
			chance of 70%:
				send "&6The gods answer and give you food!" to player
				play sound "entity.elder_guardian.curse" with pitch 2 at player
				giveItem(player, 10 bread)
				stop
		arg 1 is "strength":
			chance of 40%:
				send "&6The gods answer and give you strength!" to player
				play sound "item.trident.thunder" with pitch 2.0 at player
				apply regeneration 2 to player for 60 seconds replacing the existing effect
				apply saturation 2 to player for 60 seconds replacing the existing effect
				apply strength 2 to player for 60 seconds replacing the existing effect
				apply haste 2 to player for 60 seconds replacing the existing effect
				apply resistance 2 to player for 60 seconds replacing the existing effect
				stop
		wait 30 ticks
		send "&6The gods do not seem to answer..." to player
		play sound "entity.elder_guardian.ambient" with pitch 0.7 at player

command /channel <text>:
	executable by: players
	trigger:
		hasClass(player, "cleric") is true
		if arg 1 is "regen":
			subMana(player, 300) is false:
				send "&cYou do not have enough mana to bless nearby allies with regeneration!" to player
				stop
			loop players in radius 20 of player:
				apply regeneration 2 to loop-player for 1800 seconds replacing the existing effect
				send "&6A Cleric blesses you with regeneration!" to loop-player
			play sound "item.trident.thunder" with pitch 2.0 at player
			send "&6You bless your allies with regeneration!" to player
		else if arg 1 is "haste":
			subMana(player, 300) is false:
				send "&cYou do not have enough mana to bless nearby allies with haste!" to player
				stop
			loop players in radius 20 of player:
				apply haste 2 to loop-player for 1800 seconds replacing the existing effect
				send "&6A Cleric blesses you with haste!" to loop-player
			play sound "item.trident.thunder" with pitch 2.0 at player
			send "&6You bless your allies with haste!" to player
		else if arg 1 is "absorb":
			subMana(player, 300) is false:
				send "&cYou do not have enough mana to bless nearby allies with absorption!" to player
				stop
			loop players in radius 20 of player:
				apply absorption 5 to loop-player for 300 seconds replacing the existing effect
				send "&6A Cleric blesses you with absorption!" to loop-player
			play sound "item.trident.thunder" with pitch 2.0 at player
			send "&6You bless your allies with absorption!" to player
		else if arg 1 is "day":
			subMana(player, 400) is false:
				send "&cYou do not have enough mana!" to player
				stop
			set time in (world of player) to 6:00
			play sound "item.trident.thunder" with pitch 2.0 at player
			send "&6Time changes to day!" to player
		else if arg 1 is "night":
			subMana(player, 400) is false:
				send "&cYou do not have enough mana!" to player
				stop
			set time in (world of player) to 20:00
			play sound "item.trident.thunder" with pitch 2.0 at player
			send "&6Time changes to night!" to player
		else:
			send "&cUnrecognized ability" to player



# Barbarian



function rageTrigger(player: player):
	play sound "entity.player.attack.nodamage" at {_player}
	apply resistance 1 without particles to {_player} for 15 seconds replacing the existing effect
	apply swiftness 1 without particles to {_player} for 15 seconds replacing the existing effect
	apply strength 1 without particles to {_player} for 15 seconds replacing the existing effect
	apply regeneration 1 without particles to {_player} for 15 seconds replacing the existing effect

function setupRage(player: player):
	if {rpgSkript::%{_player}%::rage} is not set:
		set {rpgSkript::%{_player}%::rage} to 0
	if {rpgSkript::%{_player}%::maxRage} is not set:
		set {rpgSkript::%{_player}%::maxRage} to 0

	set {_newRage} to 0
	if hasClass({_player}, "barbarian") is true:
		set {_newRage} to 5

	if hasImbue({_player}, "Rage Boost") is true:
		set {_newRage} to {_newRage} + 0.25 * {_newRage} * countImbue({_player}, "Rage Boost")

	set {_newRage} to floor({_newRage})
	if {_newRage} is not {rpgSkript::%{_player}%::maxRage}:
		set {rpgSkript::%{_player}%::maxRage} to {_newRage}
		send "&4Your maximum Rage has changed to %{_newRage}%" to {_player}

function checkRage(player: player):
	setupRage({_player})
	if {rpgSkript::%{_player}%::rage} > {rpgSkript::%{_player}%::maxRage}:
		set {rpgSkript::%{_player}%::rage} to {rpgSkript::%{_player}%::maxRage}
	if {rpgSkript::%{_player}%::rage} < 0:
		set {rpgSkript::%{_player}%::rage} to 0

function regenRage(player: player):
	if {rpgSkript::%{_player}%::rage} is not set:
		setupRage({_player})
	if {rpgSkript::%{_player}%::maxRage} is not set:
		setupRage({_player})

	set {_add} to 0
	if hasClass({_player}, "barbarian") is true:
		set {_add} to {rpgSkript::%{_player}%::maxRage} / 150
		
	addRage( {_player}, {_add} )

function addRage(player: player, amount: number):
	set {_before} to {rpgSkript::%{_player}%::rage}
	set {rpgSkript::%{_player}%::rage} to {rpgSkript::%{_player}%::rage} + {_amount}
	checkRage({_player})
	if abs( {rpgSkript::%{_player}%::rage} - {_before} ) > 0.01:
		displayRage({_player})

function subRage(player: player, amount: number, print: boolean=true) :: boolean:
	{_player} has permission "rpg.control":
		return true
	if {rpgSkript::%{_player}%::rage} is not set:
		return false
	if hasRage({_player}, {_amount}, {_print}) is true:
		set {rpgSkript::%{_player}%::rage} to {rpgSkript::%{_player}%::rage} - {_amount}
		checkRage({_player})
		displayRage({_player})
		return true
	else:
		return false

function hasRage(player: player, amount: number, print: boolean=true) :: boolean:
	{_player} has permission "rpg.control":
		return true
	if {_print} is true:
		send "&4Rage: Have %{rpgSkript::%{_player}%::rage}%, Need %{_amount}%" to {_player}
	if {rpgSkript::%{_player}%::rage} - {_amount} > -0.01:
		return true
	return false

function displayRage(player: player):
	set {_dispR} to {rpgSkript::%{_player}%::rage}
	if {_dispR} < 0:
		set {_dispR} to 0
	send action bar "&4Rage: %{_dispR}% / %{rpgSkript::%{_player}%::maxRage}%" to {_player}

command /barbarianresearch:
	executable by: players
	trigger:
		hasClass(player, "barbarian") is false:
			send "&dYou are not a barbarian!"
			exit
		set {_menu} to a new chest inventory with 6 rows named "&cBarbarian Research"
		
		populateBarbarianResearchMenu(player, {_menu})
		
		open {_menu} to player

function populateBarbarianResearchMenu(player: player, menu: inventory):
	set {_item} to red wool named "&7Poison Barbs"
	if hasResearch({_player}, "poison_barbs") is true:
		set {_item} to lime wool named "&ePoison Barbs"
	set line 1 of {_item}'s lore to "&6Your repelling attack also inflicts poison on the enemy"
	set slot 30 of {_menu} to {_item}
	
	set {_item} to red wool named "&7Leap"
	if hasResearch({_player}, "leap") is true:
		set {_item} to lime wool named "&eLeap"
	set line 1 of {_item}'s lore to "&6R-Clicking Glowstone Dust causes you to leap in the air, creating an earthquake on impact"
	set slot 31 of {_menu} to {_item}
	
	set {_item} to red wool named "&7Reckless Attack"
	if hasResearch({_player}, "reckless_attack") is true:
		set {_item} to lime wool named "&eReckless Attack"
	set line 1 of {_item}'s lore to "&6Rerolls low damage hits to either increase the damage or set it to 0"
	set slot 32 of {_menu} to {_item}

	set {_item} to red wool named "&7Throwables"
	if hasResearch({_player}, "throwables") is true:
		set {_item} to lime wool named "&ethrowables"
	set line 1 of {_item}'s lore to "&6Eggs and Snowballs can be used to deal damage when thrown."
	set slot 33 of {_menu} to {_item}

on inventory click:
	event-inventory is not event-player's inventory
	name of event-inventory is "&cBarbarian Research"
	cancel event

	if index of event-slot is 30:
		if hasResearch(player, "poison_barbs") is true:
			deleteResearch(player, "poison_barbs")
		else:
			takeItems( player, (1 potion of poison) ) is false:
				send "&4~ ~ Need 1 Potion of Poison for this Research ~ ~" to player
				stop
			addResearch(player, "poison_barbs")

	if index of event-slot is 31:
		if hasResearch(player, "leap") is true:
			deleteResearch(player, "leap")
		else:
			takeItems( player, (1 potion of leaping and 16 ghast tear ) ) is false:
				send "&4~ ~ Need 1 Potion of Leaping & 16 Ghast Tears for this Research ~ ~" to player
				stop
			addResearch(player, "leap")

	if index of event-slot is 32:
		if hasResearch(player, "reckless_attack") is true:
			deleteResearch(player, "reckless_attack")
		else:
			takeItems( player, (32 red dye and 64 redstone dust ) ) is false:
				send "&4~ ~ Need 32 Red Dye & 64 Redstone Dust for this Research ~ ~" to player
				stop
			addResearch(player, "reckless_attack")

	if index of event-slot is 33:
		if hasResearch(player, "throwables") is true:
			deleteResearch(player, "throwables")
		else:
			takeItems( player, (16 egg, 16 snowball, and 32 red dye ) ) is false:
				send "&4~ ~ Need 16 Eggs, 16 Snowballs, and 32 Red Dye for this Research ~ ~" to player
				stop
			addResearch(player, "throwables")
	
	populateBarbarianResearchMenu(player, event-inventory)

function canUseBarbarianAbilities(player: player) :: boolean:
	if {_player} has potion effect weakness:
		return false
	else if {_player}'s off hand item is a shield:
		return false
	else if isWearingMediumOrLess({_player}) is true:
		return true
	return false

on right click with red dye:
	hasClass(event-player, "barbarian") is true
	canUseBarbarianAbilities(event-player) is true
	subRage(event-player, 1) is true:
		rageTrigger(event-player)

on right click with glowstone dust:
	player is sprinting
	player is on the ground
	if hasClass(player, "barbarian") is true:
		if canUseBarbarianAbilities(player) is true:
			if hasResearch(player, "leap") is true:
				subRage(player, 1) is true:
					push player horizontally forward with force 1.9
					push player upwards with force 0.95
					send "&cYou leap!" to player
					wait 5 ticks
					while player is not on ground:
						wait 1 tick
					send "&cYou crush nearby enemies!" to player
					loop all entities in radius 6 around player:
						loop-entity is not player
						damage loop-entity by 3.5
						apply slowness 1 to loop-entity for 5 seconds replacing the existing effect
						set {_vec} to vector between player and loop-entity
						set y component of {_vec} to 0
						set {_vec} to normalized {_vec}
						push loop-entity {_vec} with force 1.6
						push loop-entity upwards with force 0.9



# Endwarden



function canUseEndwardenAbilities(player: player) :: boolean:
	if block at {_player} is water:
		return false
	else if isWearingMediumOrLess({_player}) is true:
		return true
	return false

on right click with end crystal:
	hasClass(event-player, "endwarden") is true:
		canUseEndwardenAbilities(event-player) is true:
			if getPlayerLevel(event-player) is greater than 50:
				if {rpgSkript::%event-player%::mana} > 0:
					set {_emana} to {rpgSkript::%event-player%::mana}
					subMana(player, {rpgSkript::%event-player%::mana}) is true:
						set {_btime} to generateTime( min( {_emana}/80 + 5, 15 ) )
						set {_wtime} to generateTime( min( {_emana}/30 + 5, 15 ) )
						loop all entities in radius 30 around event-player:
							if loop-entity is not event-player:
								if loop-entity is a player:
									play sound "block.end_portal.spawn" at loop-entity
									apply blindness 2 to loop-entity for {_btime} replacing the existing effect
									apply weakness 1 to loop-entity for {_wtime} replacing the existing effect
									apply levitation 1 to the loop-entity for 5 seconds replacing the existing effect
								isMonster(loop-entity) is true:
									apply weakness 1 to loop-entity for {_wtime} replacing the existing effect
									apply levitation 1 to the loop-entity for 5 seconds replacing the existing effect
								isMinion(loop-entity) is true:
									if getSummoner(uuid of loop-entity) is not event-player:
										apply weakness 1 to loop-entity for {_wtime} replacing the existing effect
										apply levitation 1 to the loop-entity for 5 seconds replacing the existing effect
						play sound "block.end_portal.spawn" at player

on left click with end crystal:
	hasClass(event-player, "endwarden") is true:
		subMana(event-player, 300) is true:
			send "&2~ ~ RADIATE AN ENDER FIELD ~ ~" to event-player
			play sound "block.end_portal.spawn" at event-player
			loop entities in radius 20 of event-player:
				isMonster(loop-entity) is true:
					chance of 50%:
						apply levitation 1 to the loop-entity for 5 seconds replacing the existing effect
				loop-entity is a player:
					loop-entity is not event-player:
						chance of 25:
							apply levitation 1 to the loop-entity for 5 seconds replacing the existing effect
							send "&2~ ~ AN END FIELD WASHES OVER YOU ~ ~" to loop-entity
				isMinion(loop-entity) is true:
					if getSummoner(uuid of loop-entity) is event-player:
						apply regeneration 1 to loop-entity for 10 seconds replacing the existing effect
					else:
						apply levitation 1 to the loop-entity for 5 seconds replacing the existing effect

on right click with (ender pearl or eye of ender):
	hasClass(event-entity, "endwarden") is true:
		event-entity's off hand item is an ender pearl:
			cancel the event
		event-entity's off hand item is an eye of ender:
			cancel the event

on right click with phantom membrane:
	if {rpgSkript::%event-player%::eteleport} is true:
		endTeleport(event-player)
		wait 25 seconds
		set {rpgSkript::%event-player%::eteleport} to true
		send "&cTeleport Cooldown Finished!" to event-player
	else:
		send "&cTeleport on Cooldown!" to event-player

function endTeleport( player: player):
	hasClass({_player}, "endwarden") is true:
		canUseEndwardenAbilities({_player}) is true:
			set {_loc} to {_player}'s targeted block
			set {_loc} to location 1 meter above {_loc}
			set pitch of {_loc} to pitch of {_player}
			set yaw of {_loc} to yaw of {_player}

			set {_canTp} to true
			if block at {_loc} is solid:
				set {_canTp} to false
			if block 1 meter above {_loc} is solid:
				set {_canTp} to false
			if {_canTp} is false:
				send "&cCannot teleport there!" to {_player}
				stop
		
			if subMana({_player}, 40) is false:
				send "&cYou do not have enough Mana to teleport!" to {_player}
				stop
			set {rpgSkript::%{_player}%::eteleport} to false
			send "&dYou teleport to your target location!" to {_player}
			play sound "entity.enderman.teleport" at {_player}
			teleport {_player} to {_loc}
			wait 2 ticks
			play sound "entity.enderman.teleport" at {_player}

on left click with phantom membrane:
	hasClass(event-player, "endwarden") is true:
		canUseEndwardenAbilities(event-player) is true:
			subMana(event-player, 100) is true:
				play sound "entity.enderman.teleport" at event-player
				send "&dYou cast a spell to quicken your minions!" to event-player
				loop entities in radius 10 of event-player:
					isMinion(loop-entity) is true:
						getSummoner(uuid of loop-entity) is event-player:
							apply haste 1 to the loop-entity for 20 seconds replacing the existing effect
							apply swiftness 1 to the loop-entity for 20 seconds replacing the existing effect

on left click with shulker shell:
	hasClass(event-player, "endwarden") is true:
		canUseEndwardenAbilities(event-player) is true:
			subMana(event-player, 100) is true:
				play sound "entity.enderman.teleport" at event-player
				send "&dYou cast a spell to harden your minions!" to event-player
				loop entities in radius 10 of event-player:
					isMinion(loop-entity) is true:
						getSummoner(uuid of loop-entity) is event-player:
							apply resistance 1 to the loop-entity for 20 seconds replacing the existing effect
							apply health boost 2 to the loop-entity for 20 seconds replacing the existing effect
							
on right click with shulker shell:
	if getPlayerLevel(event-player) is greater than 25:
		hasClass(event-player, "endwarden") is true:
			canUseEndwardenAbilities(event-player) is true:
				subMana(event-player, 150) is true:
					play sound "minecraft:entity.shulker_box.close1" with pitch 0.7 at player
					send "&dYour skins hardens like a shulker!" to event-player
					apply resistance 3 to the event-player for 10 seconds replacing the existing effect

on right click with purple dye:
	hasClass(player, "endwarden") is true
	if subMana(command executor, 30) is false:
		send "&cYou do not have enough Mana to summon an Enderman!" to command executor
		stop
	send "&dYou summon an Enderman!" to command executor
	set {_player} to the player
	spawn 1 enderman at the player:
		setupMinion(the enderman, {_player})



# Druid



every 10 seconds:
	loop all players:
		hasClass(loop-player, "druid") is true:
			canUseDruidAbilities(loop-player) is true:
				if {rpgSkript::%loop-player%::humanshape} is true:
					loop all blocks in radius 10 around loop-player:
						chance of 5%:
							if loop-block is wheat:
								apply bone meal to loop-block
								wait 20 ticks
							if loop-block is carrot plant:
								apply bone meal to loop-block
								wait 20 ticks
							if loop-block is potato plant:
								apply bone meal to loop-block
								wait 20 ticks
							if loop-block is melon stem:
								apply bone meal to loop-block
								wait 20 ticks
							if loop-block is pumpkin stem:
								apply bone meal to loop-block
								wait 20 ticks
							if loop-block is sweet berry bush:
								apply bone meal to loop-block
								wait 20 ticks
							if loop-block is beetroot plant:
								apply bone meal to loop-block
								wait 20 ticks
							if loop-block is sugar cane:
								block above loop-block is air:
									block below loop-block is not sugar cane:
										set block above loop-block to sugar cane
								wait 20 ticks
							if loop-block is bamboo:
								block above loop-block is air:
									set block above loop-block to bamboo
								wait 20 ticks
							if loop-block is a sapling:
								apply bone meal to loop-block
								wait 20 ticks

function canUseDruidAbilities(player: player) :: boolean:
	if {_player} has potion effect wither:
		return false	
	if isWearingLightOrLess({_player}) is true:
		return true
	return false

function canUseShapeshiftAbilities(player: player) :: boolean:
	helmet of {_player} is not (air):
		hasLore(helmet of {_player}, "shapeshifter") is false:
			return false
	chestplate of {_player} is not (air):
		hasLore(chestplate of {_player}, "shapeshifter") is false:
			return false
	leggings of {_player} is not (air):
		hasLore(leggings of {_player}, "shapeshifter") is false:
			return false
	boots of {_player} is not (air):
		hasLore(boots of {_player}, "shapeshifter") is false:
			return false
	off hand item of {_player} is shield:
		hasLore(off hand item of {_player}, "shapeshifter") is false:
			return false
	return false

command /druidresearch:
	executable by: players
	trigger:
		hasClass(player, "druid") is false:
			send "&dYou are not a druid!"
			exit
		set {_menu} to a new chest inventory with 6 rows named "&cDruid Research"
		
		populateDruidResearchMenu(player, {_menu})
		
		open {_menu} to player

function populateDruidResearchMenu(player: player, menu: inventory):
	set {_item} to red wool named "&7Polar Bear"
	if hasResearch({_player}, "polar_bear") is true:
		set {_item} to lime wool named "&ePolar Bear"
	set line 1 of {_item}'s lore to "&6Replaces Wolf summon with Polar Bear"
	set slot 30 of {_menu} to {_item}

	set {_item} to red wool named "&7Wildshape Charges"
	if hasResearch({_player}, "wildshape_charges") is true:
		set {_item} to lime wool named "&ewildshape_charges"
	set line 1 of {_item}'s lore to "&6Grants the user one more Wildshape Charge per level"
	set slot 31 of {_menu} to {_item}


on inventory click:
	event-inventory is not event-player's inventory
	name of event-inventory is "&cDruid Research"
	cancel event

	if index of event-slot is 30:
		if hasResearch(player, "polar_bear") is true:
			deleteResearch(player, "polar_bear")
		else:
			addResearch(player, "polar_bear")

	if index of event-slot is 31:
		if hasResearch(player, "wildshape_charge") is true:
			if takeItems( player, (32 leather, 32 egg, and 16 poppy ) ) is false:
				send "&cDo not have the necessary items to level this up! Items Needed: 32 Leather, 32 Egg, and 16 Poppy" to player
				stop
			addResearch(player, "wildshape_charge_2")
		else:
			if takeItems( player, (16 egg and 8 dandelion ) ) is false:
				send "&cDo not have the necessary items to unlock this! Items Needed: 16 Egg and 8 Dandelion" to player
				stop
			addResearch(player, "wildshape_charge")

	
	populateDruidResearchMenu(player, event-inventory)

on right click with leather:
	hasClass(player, "druid") is true
	canUseDruidAbilities(event-player) is true
	if hasResearch(player, "polar_bear") is false:
		if subMana(command executor, 30) is false:
			send "&cYou do not have enough Mana to summon a Wolf!" to command executor
			stop
		send "&dYou summon a wolf!" to command executor
		set {_player} to the player
		spawn 1 wolf at the player:
			setupMinion(the wolf, {_player})
	else:
		if subMana(command executor, 60) is false:
			send "&cYou do not have enough Mana to summon a Polar Bear!" to command executor
			stop
		send "&dYou summon a Polar Bear!" to command executor
		set {_player} to the player
		spawn 1 polar bear at the player:
			setupMinion(the polar bear, {_player})

on right click with spider eye:									
	hasClass(player, "druid") is true
	canUseDruidAbilities(event-player) is true
	if subMana(command executor, 40) is false:
		send "&cYou do not have enough Mana to summon a Spider!" to command executor
		stop
	send "&dYou summon a Spider!" to command executor
	set {_player} to the player
	spawn 1 spider at the player:
		setupMinion(the spider, {_player})

on right click with string:
	hasClass(event-player, "druid") is true:
		cancel the event
		canUseDruidAbilities(event-player) is true:
			if {rpgSkript::%event-player%::cobweb} is true:
				if at least one of:
					{rpgSkript::%event-player%::humanshape} is true
					{rpgSkript::%event-player%::spidershape} is true
				then:
					subMana(event-player, 50) is true:	
						set {rpgSkript::%event-player%::cobweb} to false
						set {_loc} to event-player's targeted block
						loop all blocks in radius 3 around {_loc}:
							if loop-block is air:
								set loop-block to cobweb
						loop 6 times:
							loop all entities in radius 3 around {_loc}:
								loop-entity is not event-player:
									isMinion(loop-entity) is true:
										getSummoner(uuid of loop-entity) is event-player:
											stop
									damage loop-entity by 1.5
							wait 0.5 seconds
						loop all blocks in radius 3 around {_loc}:
							if loop-block is cobweb:
								set loop-block to air
						wait 5 seconds
						set {rpgSkript::%event-player%::cobweb} to true
						send "&cCobweb Cooldown Finished!" to event-player
				else:
					send "&6Must be in Human or Spider form to use!" to event-player
			else:
				send "&aCobweb on Cooldown!" to event-player

on right click with glistering melon slice:
	hasClass(event-player, "druid") is true:
		canUseDruidAbilities(event-player) is true:
			subMana(event-player, 50) is true:
				loop all entities in radius 15 around event-player:
					isMinion(loop-entity) is true:
						getSummoner(uuid of loop-entity) is event-player:
							apply resistance 2 to the loop-entity for 15 seconds replacing the existing effect
							apply regeneration 2 to the loop-entity for 15 seconds replacing the existing effect
							apply strength 2 to the loop-entity for 15 seconds replacing the existing effect

command /wildshape <text>:
	description: Shapeshift into an Animilistic Form
	executable by: players
	trigger:
		if hasClass(command executor, "druid") is true:
			if canUseDruidAbilities(command executor) is true:
				if arg 1 is "human":
					set {rpgSkript::%command executor%::spidershape} to false
					set {rpgSkript::%command executor%::horseshape} to false
					set {rpgSkript::%command executor%::batshape} to false
					set {rpgSkript::%command executor%::bearshape} to false
					set {rpgSkript::%command executor%::wolfshape} to false
					set {rpgSkript::%command executor%::humanshape} to true
				else if subWildshape(command executor, 1) is false:
					send "&9~ ~ Not enough Wildshape to shapeshift. Must have 1 Wildshape ~ ~" to command executor
					stop
				else if arg 1 is "bat":
					set {rpgSkript::%command executor%::spidershape} to false
					set {rpgSkript::%command executor%::horseshape} to false
					set {rpgSkript::%command executor%::batshape} to true
					set {rpgSkript::%command executor%::bearshape} to false
					set {rpgSkript::%command executor%::wolfshape} to false
					set {rpgSkript::%command executor%::humanshape} to false
				else if arg 1 is "bear":
					set {rpgSkript::%command executor%::spidershape} to false
					set {rpgSkript::%command executor%::horseshape} to false
					set {rpgSkript::%command executor%::batshape} to false
					set {rpgSkript::%command executor%::bearshape} to true
					set {rpgSkript::%command executor%::wolfshape} to false
					set {rpgSkript::%command executor%::humanshape} to false
				else if arg 1 is "wolf":
					set {rpgSkript::%command executor%::spidershape} to false
					set {rpgSkript::%command executor%::horseshape} to false
					set {rpgSkript::%command executor%::batshape} to false
					set {rpgSkript::%command executor%::bearshape} to false
					set {rpgSkript::%command executor%::wolfshape} to true
					set {rpgSkript::%command executor%::humanshape} to false
				else if arg 1 is "horse":
					set {rpgSkript::%command executor%::spidershape} to false
					set {rpgSkript::%command executor%::horseshape} to true
					set {rpgSkript::%command executor%::batshape} to false
					set {rpgSkript::%command executor%::bearshape} to false
					set {rpgSkript::%command executor%::wolfshape} to false
					set {rpgSkript::%command executor%::humanshape} to false
				else if arg 1 is "spider":
					set {rpgSkript::%command executor%::spidershape} to true
					set {rpgSkript::%command executor%::horseshape} to false
					set {rpgSkript::%command executor%::batshape} to false
					set {rpgSkript::%command executor%::bearshape} to false
					set {rpgSkript::%command executor%::wolfshape} to false
					set {rpgSkript::%command executor%::humanshape} to false
				else:
					send "&9~ ~ Not a valid Wildshape. Valid Wildshapes: bat, bear, wolf, spider, horse, & human ~ ~" to command executor
					stop
				send "&9~ ~ Successfuly wild shaped ~ ~" to command executor
			else:
				send "&9~ ~ Cannot shapeshift right now ~ ~" to command executor
		else:
			send "&9~ ~ Shapeshift? You're no druid ~ ~" to command executor

function setupWildshape(player: player):
	if {rpgSkript::%{_player}%::wildshape} is not set:
		set {rpgSkript::%{_player}%::wildshape} to 0
	if {rpgSkript::%{_player}%::maxWildshape} is not set:
		set {rpgSkript::%{_player}%::maxWildshape} to 0

	set {_newWildshape} to 0
	if hasClass({_player}, "druid") is true:
		set {_newWildshape} to 3

	if hasImbue({_player}, "Wildshape Boost") is true:
		set {_newWildshape} to {_newWildshape} + 0.5 * {_newWildshape} * countImbue({_player}, "Wildshape Boost")

	set {_newWildshape} to floor({_newWildshape})
	if {_newWildshape} is not {rpgSkript::%{_player}%::maxWildshape}:
		set {rpgSkript::%{_player}%::maxWildshape} to {_newWildshape}
		send "&6Your maximum Wildshape has changed to %{_newWildshape}%" to {_player}

function checkWildshape(player: player):
	setupWildshape({_player})
	if {rpgSkript::%{_player}%::wildshape} > {rpgSkript::%{_player}%::maxWildshape}:
		set {rpgSkript::%{_player}%::wildshape} to {rpgSkript::%{_player}%::maxWildshape}
	if {rpgSkript::%{_player}%::wildshape} < 0:
		set {rpgSkript::%{_player}%::wildshape} to 0

function regenWildshape(player: player):
	if {rpgSkript::%{_player}%::wildshape} is not set:
		setupWildshape({_player})
	if {rpgSkript::%{_player}%::maxWildshape} is not set:
		setupWildshape({_player})

	set {_add} to 0
	if hasClass({_player}, "druid") is true:
		set {_add} to 1
	
	addWildshape( {_player}, {_add} )

function addWildshape(player: player, amount: number):
	set {_before} to {rpgSkript::%{_player}%::wildshape}
	set {rpgSkript::%{_player}%::wildshape} to {rpgSkript::%{_player}%::wildshape} + {_amount}
	checkWildshape({_player})
	if abs( {rpgSkript::%{_player}%::wildshape} - {_before} ) > 0.01:
		displayWildshape({_player})

function subWildshape(player: player, amount: number, print: boolean=true) :: boolean:
	{_player} has permission "rpg.control":
		return true
	if {rpgSkript::%{_player}%::wildshape} is not set:
		return false
	if hasWildshape({_player}, {_amount}, {_print}) is true:
		set {rpgSkript::%{_player}%::wildshape} to {rpgSkript::%{_player}%::wildshape} - {_amount}
		checkWildshape({_player})
		displayWildshape({_player})
		return true
	else:
		return false

function hasWildshape(player: player, amount: number, print: boolean=true) :: boolean:
	{_player} has permission "rpg.control":
		return true
	if {_print} is true:
		send "&6Wildshape: Have %{rpgSkript::%{_player}%::wildshape}%, Need %{_amount}%" to {_player}
	if {rpgSkript::%{_player}%::wildshape} - {_amount} > -0.01:
		return true
	return false

function displayWildshape(player: player):
	set {_dispW} to {rpgSkript::%{_player}%::wildshape}
	if {_dispW} < 0:
		set {_dispW} to 0
	send action bar "&6Wildshape: %{_dispW}% / %{rpgSkript::%{_player}%::maxWildshape}%" to {_player}



# Artificer



#on preparing craft:
	#hasClass(event-player, "artificer") is true:
		#if at least one of:
			#event-item is any planks
			#event-item is any stone
			#event-item is any slab
			#event-item is any stair
		#then:
			# add 2 to item amount of event-item

command /fix:
	executable by: players
	trigger:
		if hasClass(player, "artificer") is true:
			subMana(player, 100) is false:
				send "&cNot enough Mana to fix this item" to the player
				stop
			send "&bYou successfully repair your held item!" to the player
			repair player's held item
		else:
			send "&cYou are not an Artificer" to the player		

command /artifice <text>:
	executable by: players
	trigger:
		if hasClass(player, "artificer") is true:
			canArtifice(player's held item) is false:
				send "&cThis item has been artificed the max amount of times!" to the player
				stop
			subMana(player, 100) is false:
				send "&cYou do not have that amount of mana available" to the player
				stop

			set {_imbue} to arg 1
			set {_item} to player's held item

			if isArmorArtificeImbue({_imbue}) is true:
				if at least one of:
					player's held item is any armor
					player's held item is a shield
				then:
					if takeItems(player, getItemCostForImbue({_imbue})) is true:
						set player's held item to addImbue({_item}, "&b%{_imbue}%")
					else:
						send "&cYou do not have the required items to add that imbuement!" to player
				else:
					send "&cWrong item for that Artifice! %{_imbue}% must goes on Armor!" to the player
			else if isWeaponArtificeImbue({_imbue}) is true:
				if at least one of:
					player's held item is a sword
					player's held item is an axe
					player's held item is a bow
					player's held item is a crossbow
					player's held item is a trident
				then:
					if takeItems(player, getItemCostForImbue({_imbue})) is true:
						set player's held item to addImbue({_item}, "&b%{_imbue}%")
					else:
						send "&cYou do not have the required items to add that imbuement!" to player
				else:
					send "&cWrong item for that Artifice! %{_imbue}% must goes on Weapons!" to the player
			else if isToolArtificeImbue({_imbue}) is true:
				if at least one of:
					player's held item is a pickaxe
					player's held item is an axe
					player's held item is a shovel
					player's held item is a hoe
					player's held item are shears
				then:
					if takeItems(player, getItemCostForImbue({_imbue})) is true:
						set player's held item to addImbue({_item}, "&b%{_imbue}%")
					else:
						send "&cYou do not have the required items to add that imbuement!" to player
				else:
					send "&cWrong item for that Artifice! %{_imbue}% must goes on Tools!" to the player
			else:
				send "&cNot a Valid Artifice!" to the player
				stop
			send "&bYou successfully artifice your held item!" to the player
		else:
			send "&cYou are not an Artificer" to the player

command /worktable:
	executable by: players
	trigger:
		if hasClass(player, "artificer") is true:
			show crafting table to player
		else:
			send "&cNot an Artificer" to the player

function isArmorArtificeImbue(imbue: text) :: boolean:
	if at least one of:
		{_imbue} is "golem"
		{_imbue} is "mana shield"
		{_imbue} is "flame shield"
		{_imbue} is "frost shield"
		{_imbue} is "iron will"
	then:
		return true
	return false

function isWeaponArtificeImbue(imbue: text) :: boolean:
	if at least one of:
		{_imbue} is "vampiric"
		{_imbue} is "hallowed"
		{_imbue} is "bleeding"
		{_imbue} is "shocking"
		{_imbue} is "mana leak"
		{_imbue} is "repulsor"
		{_imbue} is "firststrike"
		{_imbue} is "detonate"
		{_imbue} is "enlighten"
	then:
		return true
	return false

function isToolArtificeImbue(imbue: text) :: boolean:
	if at least one of:
		{_imbue} is "excavation"
		{_imbue} is "enlighten"
	then:
		return true
	return false

function canArtifice(item: item) :: boolean:
	if lastLoreLine({_item}) > 3:
		return false
	return true

function getMaxArtificerMana(player: player) :: number:
	set {_anvil} to false
	set {_crafting} to false
	set {_blast} to false
	set {_furnace} to false
	set {_brewing} to false
	set {_enchanting} to false
	set {_grindstone} to false
	set {_smithing} to false
	set {_stonecutter} to false

	set {_newMax} to 0

	set {_loc} to location of {_player}
	set {_loc} to the location 1 meter above {_loc}

	loop all blocks in radius 4 around {_loc}:
		if loop-block is an anvil:
			if {_anvil} is false:
				set {_newMax} to {_newMax} + 40
				set {_anvil} to true
		if loop-block is a crafting table:
			if {_crafting} is false:
				set {_newMax} to {_newMax} + 10
				set {_crafting} to true
		if loop-block is an enchanting table:
			if {_enchanting} is false:
				set {_newMax} to {_newMax} + 40
				set {_enchanting} to true
		if loop-block is a smithing table:
			if {_smithing} is false:
				set {_newMax} to {_newMax} + 50
				set {_smithing} to true
		if loop-block is a furnace:
			if {_furnace} is false:
				set {_newMax} to {_newMax} + 25
				set {_furnace} to true
		if loop-block is an blast furnace:
			if {_blast} is false:
				set {_newMax} to {_newMax} + 35
				set {_blast} to true
		if loop-block is a grindstone:
			if {_grindstone} is false:
				set {_newMax} to {_newMax} + 20
				set {_grindstone} to true
		if loop-block is a stonecutter:
			if {_stonecutter} is false:
				set {_newMax} to {_newMax} + 35
				set {_stonecutter} to true

	return {_newMax}

on mine of (sand or gravel or dirt or grass block):
	hasLore(event-player's held item, "excavation") is true:
		loop all blocks in radius 1.99 around event-block:
			if at least one of:
				loop-block is sand
				loop-block is gravel
				loop-block is dirt
				loop-block is grass block
			then:
				break loop-block naturally using diamond shovel

on projectile hit:
	hasLore(shooter's held item, "Repulsor") is true:
		loop all entities in radius 10 around event-projectile:
			push loop-entity in the direction of event-projectile at speed 2.5
	hasLore(shooter's held item, "Detonate") is true:
		detonate(block at event-projectile, 2.5)
		loop all entities in radius 5 around event-projectile:
			loop-entity is not a dropped item
			damage loop-entity by 4.5
		create a fake explosion at event-projectile
	hasLore(shooter's held item, "electric smoke") is true:
		createWorldEffect(location of event-projectile, "electric_smoke", 20 seconds, shooter)

function detonate(block: block, range: number):
	loop all blocks in radius {_range} around {_block}:
		if at least one of:
			loop-block is gravel
			loop-block is dirt
			loop-block is grass block
			loop-block is sand
			loop-block is any leaves
		then:
			break loop-block naturally using diamond pickaxe

